<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MY+</title>
  
  <subtitle>子非鱼，安知鱼之乐！</subtitle>
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://suiang.cn/"/>
  <updated>2020-09-10T18:13:35.020Z</updated>
  <id>http://suiang.cn/</id>
  
  <author>
    <name>苏扬</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程入门</title>
    <link href="http://suiang.cn/posts/1014/"/>
    <id>http://suiang.cn/posts/1014/</id>
    <published>2020-09-10T18:07:06.447Z</published>
    <updated>2020-09-10T18:13:35.020Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>当你点击EXE文件系统一个应用程序的时候 - 系统会创建一个进程（process）<br>而在一个进程内可以包含多个线程(thread)。用来显示界面的线程，我们通常称为“界面线程”，<br>其他不是用来显示界面的线程，我们一般称为“工作线程”或者是“后台线程”。</p></blockquote><a id="more"></a><p>界面线程会使用 <code>win.loopMessage();</code> 启动一个消息循环，<br><code>win.loopMessage();</code>  就象一个快递公司不知疲倦的收发消息，直到用户关闭最后一个窗口他才会退出。<br>当然你也可以使用 <code>win.quitMessage()</code> 退出消息循环。</p><p>下面是一个启动界面线程的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win.ui;</span><br><span class="line"><span class="comment">/*DSG&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">var</span> winform = win.form(text=<span class="string">"aardio form"</span>;right=<span class="number">759</span>;bottom=<span class="number">469</span>)</span><br><span class="line">winform.add(</span><br><span class="line">    button=&#123;cls=<span class="string">"button"</span>;text=<span class="string">"耗时操作"</span>; ...&#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">/*&#125;&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用户点击窗口上的按钮时会触发下面的回调函数</span></span><br><span class="line">winform.button.oncommand = <span class="function"><span class="keyword">function</span>(<span class="params">id,event</span>)</span>&#123;   </span><br><span class="line">    <span class="comment">//下面用sleep函数休眠5秒(5000毫秒)模拟耗时操作</span></span><br><span class="line">    sleep(<span class="number">5000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">winform.show();</span><br><span class="line">win.loopMessage();</span><br></pre></td></tr></table></figure><p>你可以看到一个窗体显示在屏幕上，如果你去掉代码中的最后一句 <code>win.loopMessage();</code>那么窗体只会显示一下就消失了，你的程序也迅速退出了。</p><p>但如果你加上 <code>win.loopMessage();</code> 窗体就会一直显示在屏幕上（直到你点击关闭按钮）。<br>并且你可以做其他的操作，例如点击按钮。</p><p>我们尝试点击按钮，点击按钮后触发了 <code>winform.button.oncommand()</code> 函数，<br>一件让我们困惑的事发生了，窗体卡死了任何操作都没有反应，这是因为类似 <code>sleep(5000)</code> 这样的耗时操作阻塞了<code>win.loopMessage()</code>启动的消息循环过程。</p><p>一种解决方法是把 <code>sleep(5000)</code>改成 <code>win.delay(5000)</code>，虽然他们同样都是延时函数，但是<code>win.delay()</code>会同时继续处理窗口消息。但如果我们不只是延时还要做其他耗时的操作，那就需要启动一个新的线程。</p><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><blockquote><p>一个线程会排队执行一系列的编程指令，但一个线程同时只能做一件事。<br>例如在界面上有耗时的操作在执行时 - 就不能同时处理其他的界面消息或者响应用户的操作。<br>这时候我们就要使用多线程来完成我们的任务。</p></blockquote><p>我们假设有一个耗时操作是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这个函数执行耗时操作</span></span><br><span class="line">doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"> str </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;<span class="number">100</span>)&#123;</span><br><span class="line">        str = str + <span class="string">" "</span> + i;</span><br><span class="line">        sleep(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般我们直接调用这个函数会是这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doSomething( <span class="string">"也可以有参数什么的"</span> )</span><br></pre></td></tr></table></figure></p><p>如果希望写复杂一点调用这个函数，我们也可以这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke(doSomething ,,<span class="string">"也可以有参数什么的"</span> )</span><br></pre></td></tr></table></figure></p><p>如果我们希望创建一个新的线程来调用这个函数，那么就需要下面这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.invoke(doSomething ,<span class="string">"也可以有参数什么的"</span> )</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>切记不要犯一个低级错误：</strong><br> 如果把创建线程的代码改为 <code>thread.invoke( doSomething(&quot;也可以有参数什么的&quot;) )</code><br>这是在创建线程前就调用函数了，实际执行的代码是 <code>thread.invoke( 123 )</code> 这肯定会出错的。</p></blockquote><h3 id="线程的规则与限制"><a href="#线程的规则与限制" class="headerlink" title="线程的规则与限制"></a>线程的规则与限制</h3><blockquote><p>线程有独立的运行上下文，独立的变量环境</p></blockquote><p>多线程最让人困惑的是<u>线程间的同步和交互</u>。</p><p>线程就象多个在并列的轨道上疾驰的火车，你要在A火车上与B火车上的人交互，或者你想让B火车上的人干什么，你不能直接从火车上把手伸出去跟别的火车上的人拉拉扯扯发生种种亲密的互动。</p><ul><li>一种方式是先让所有的火车都停下来，互动完了再继续往前开，需要互动的时候再停下来，这通常需要用到线程同步的锁，在aardio中就是<code>thread.lock()</code>，但实际上在aardio中多线程同步很少需要用到同步锁，所以这里我也就不多讲。</li><li>另外一种更先进的方式就是TLS(Thread Local Storage)，也就是<strong>线程局部存储</strong>。<br>一些编程语言的全局变量是多线程共享的，一次修改多个线程中立即生效，这看起来很方便，其实带来的潜在麻烦会很多，会制造大量混乱的BUG。而aardio自带TLS, 所有变量都是线程局部存储。你不能在多线程间直接共享变量。</li></ul><h4 id="交换变量的方法"><a href="#交换变量的方法" class="headerlink" title="交换变量的方法"></a>交换变量的方法</h4><ol><li><p>如果你有一些函数需要被多个线程用到，请他们写到库文件里，然后在任何线程中使用 <code>import</code> 语句导入即可使用。</p></li><li><p>可以在创建线程时，通过线程的启动参数把变量从一个线程传入另一个线程，例如：</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.invoke( 线程启动函数,<span class="string">"给你的"</span>,<span class="string">"这也是给你的"</span>,<span class="string">"如果还想要上车后打我电话"</span> )</span><br></pre></td></tr></table></figure><ol start="3"><li><p>多线程共享的变量，必须通过 <code>thread.get()</code> 函数获取，并使用 <code>thread.set()</code> 函数修改其值，<code>thread.table</code>对象对这两个函数做了进一步的封装（伪装成一个普通的表对象）</p></li><li><p>aardio提供了很多线程间相互调用函数的方法，通过这些调用方式的传参也可以交互变量，具体请查看aardio范例中的多线程范例。</p></li></ol><h4 id="交换变量的规则"><a href="#交换变量的规则" class="headerlink" title="交换变量的规则"></a>交换变量的规则</h4><p>在aardio中每个线程有独立的运行上下文、线程有独立的变量环境，有独立的堆栈，所以你不能把包含局部变量闭包的对象从一个线程传到另一个线程，常见的就是调用类创建的对象，因为this就是闭包变量。</p><p>另外你也不可以在一个线程中引用库文件，并且把引用的库直接传到另一个线程，因为库文件中通常会大量的使用局部变量闭包，而应该在每个线程中自行导入需要用到的库，一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"></span><br><span class="line">thread.invoke(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"线程要自己调用 import console;"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.pause(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="调用窗口对象"><a href="#调用窗口对象" class="headerlink" title="调用窗口对象"></a>调用窗口对象</h3><p>新手可能不太容易理解，aardio中的这种模式给多线程开发带来了巨大的方便，在aardio的多线程代码中基本很少看到同步锁，也很少会因为同步出现各种BUG和麻烦，以前面并列飞奔的多个火车来比喻，在aardio中每辆火车都只要愉快的往前跑就行了，不存在谁停下来等谁同步的问题。</p><p>但不可否认，工作线程中如果能直接操作窗口上的控件那会带来巨大的方便（因为工作线程需要访问界面控件的需求还是非常多的），但这违反了aardio的规则，在aardio的旧版本中这是行不通的，在aardio新版本中，我们愉快的解决了这个问题。现在aardio中可以存在一些特权对象，让一些不能在线程中直接传递的对象可以跨线程传递，例如窗口对象，下面我们看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win.ui;</span><br><span class="line"><span class="keyword">var</span> winform = win.form(text=<span class="string">"aardio form"</span>;right=<span class="number">759</span>;bottom=<span class="number">469</span>)</span><br><span class="line">winform.add(</span><br><span class="line">    button=&#123;cls=<span class="string">"button"</span>;text=<span class="string">"再来个多线程，可以多点几次不会乱的"</span>; ...&#125;;</span><br><span class="line">    edit=&#123;cls=<span class="string">"edit"</span>;edge=<span class="number">1</span>;multiline=<span class="number">1</span>;z=<span class="number">1</span>; ...&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">winform.button.oncommand = <span class="function"><span class="keyword">function</span>(<span class="params">id,event</span>)</span>&#123;</span><br><span class="line">    thread.invoke(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">winform</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">1</span>;<span class="number">10</span>;<span class="number">1</span>)&#123;</span><br><span class="line">                winform.edit.print( time.tick(),<span class="string">"线程ID:"</span>,thread.getId() );</span><br><span class="line">                sleep(<span class="number">1000</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,winform</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">winform.show()</span><br><span class="line">win.loopMessage();</span><br></pre></td></tr></table></figure><blockquote><p>注意上面的线程启动函数直接写在了参数里（匿名函数），跟下面的写法作用是一样的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这个函数执行耗时操作</span></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"> winform </span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;<span class="number">10</span>;<span class="number">1</span>)&#123;</span><br><span class="line">        winform.edit.print( time.tick(),<span class="string">"线程ID:"</span>,thread.getId() );</span><br><span class="line">        sleep(<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread.invoke( doSomething,winform ) <span class="comment">//启动线程</span></span><br></pre></td></tr></table></figure><h3 id="界面与逻辑分离"><a href="#界面与逻辑分离" class="headerlink" title="界面与逻辑分离"></a>界面与逻辑分离</h3><p>在工作线程中直接操作界面控件固然令人愉快，<br>但如果代码量一大，界面与逻辑混杂在一起，会让代码不必要的变的千头万绪复杂臃肿。</p><p>如果把多线程比作多条轨道上并列飞奔的火车，那么火车交互的方法不仅仅只有停下来同步，或者把手伸出车窗来个最直接的亲密交互。一种更好的方式是拿起手机给隔壁火车上的人打个电话 - 发个消息，或者等待对方操作完了再把消息发回来。</p><p>这种响应式的编程方式在aardio里就是 <code>thead.command</code>，下面我们看一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win.ui;</span><br><span class="line"><span class="keyword">var</span> winform = win.form(text=<span class="string">"线程命令"</span>;right=<span class="number">599</span>;bottom=<span class="number">399</span>)</span><br><span class="line">winform.add(edit=&#123;cls=<span class="string">"edit"</span>; ...&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> thread.command;</span><br><span class="line"><span class="keyword">var</span> listener = thread.command();</span><br><span class="line">listener.print = <span class="function"><span class="keyword">function</span>(<span class="params"> ... </span>)</span>&#123;</span><br><span class="line">    winform.edit.print( ... ) <span class="comment">//我们在界面线程中这样响应工作线程的消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread.invoke( <span class="comment">//创建工作线程</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">import</span> thread.command; <span class="comment">//必须在线程函数内部导入需要的库</span></span><br><span class="line">        thread.command.print(<span class="string">"hello world"</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//调用界面线程的命令</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">winform.show();</span><br><span class="line">win.loopMessage();</span><br></pre></td></tr></table></figure><blockquote><p> <code>thread.command</code>可以把多线程间复杂的消息交互伪装成普通的函数调用，非常的方便。</p></blockquote><p>这里新手仍然可能会困惑一点：我在工作线程中不是可以直接操作界面控件么？！ 你这个<code>thread.command</code>虽然好用，但是多写了不少代码呀。</p><p>这样去理解是不对的，你开个轮船去对象菜市场买菜固然是有点麻烦，但如果你开轮船去环游世界那你就能感受到它的方便在哪里了。<code>thread.command</code> 一个巨大的优势是让界面与逻辑完全解耦，实现界面与逻辑的完全分离，当你的程序写到后面，代码越来越多，就能感受到这种模式的好处了。</p><p>例如 aardio自带的自动更新模块的使用示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fsys.update.dlMgr;</span><br><span class="line"><span class="keyword">var</span> dlMgr = fsys.update.dlMgr(</span><br><span class="line">    <span class="string">"http://update.aardio.com/api/v1/version.txt"</span>,<span class="string">"/download/update-files"</span>)</span><br><span class="line"></span><br><span class="line">dlMgr.onError = <span class="function"><span class="keyword">function</span>(<span class="params">err,filename</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//错误信息 err,错误文件名 filename 这里可以不用做任何处理,因为出错了就是没有升级包了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dlMgr.onConfirmDownload = <span class="function"><span class="keyword">function</span>(<span class="params">isUpdated,appVersion,latestVersion,description</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( ! isUpdated )&#123;</span><br><span class="line">        <span class="comment">//已经是最新版本了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//检测到最新版本，版本号 latestVersion</span></span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//暂不下载</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dlMgr.create();</span><br></pre></td></tr></table></figure><p>这个<code>fsys.update.dlMgr</code>里面就用到了多线程，但是他完全不需要直接操作界面控件。<br>而你在界面上使用这个对象的时候，你甚至都完全不用理会他是不是多线程，不会阻塞和卡死界面，有了结果你会收到通知，你接个电话就行了压根不用管他做了什么或者正在做什么。</p><p>这个<code>fsys.update.dlMgr</code>里面就是使用<code>thread.command</code>实现了实现界面与逻辑分离，你可以把检测、下载、更新替换并调整为不同的界面效果，但是<code>fsys.update.dlMgr</code>的代码可以始终复用。</p><h3 id="使用线程句柄"><a href="#使用线程句柄" class="headerlink" title="使用线程句柄"></a>使用线程句柄</h3><p>一般我们可以使用 <code>thread.invoke()</code> 函数简单快捷的创建线程，<br>而 <code>thread.create()</code> 的作用和用法与  <code>thread.invoke()</code> 一样，唯一的区别是 <code>thread.create()</code>会返回线程句柄。</p><p>线程句柄可以用来控制线程（暂停或继续运行等等），<br>如果不再使用线程句柄，应当使用 <code>raw.closehandle()</code> 函数关闭线程句柄（这个操作不会关停线程）</p><p>有了线程句柄，我们可以使用 <code>thread.waitOne()</code> 等待线程执行完毕，<br>而且 <code>thread.waitOne()</code> 还可以一边等待一边处理界面消息（让界面不会卡死）。</p><p>下面看一下aardio范例里的多线程入门示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thrdHandle = thread.create(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line">        thread.lock(<span class="string">"写控制台"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"线程在执行"</span>,thread.getId() )</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里如果高级点可以用 thread.event来实现信号判断,参考本目录下的定时器范例</span></span><br><span class="line">        <span class="keyword">while</span>(!thread.get(<span class="string">"红灯停"</span>))&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"线程在执行"</span>,time() )</span><br><span class="line">            sleep(<span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"停了!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">   </span><br><span class="line">thread.suspend(thrdHandle) <span class="comment">//使用线程句柄就可以控制线程,例如下面的函数暂停线程</span></span><br><span class="line">thread.resume(thrdHandle) <span class="comment">//线程恢复运行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> act = thread.stillActive(thrdHandle) <span class="comment">//线程是否在运行</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个线程的全局变量环境都是独立的,而 thread.set() 则用于设置所有线程共享的全局变量。</span></span><br><span class="line">thread.set(<span class="string">"红灯停"</span>, <span class="literal">true</span>)</span><br><span class="line">thread.waitAll(thrdHandle)</span><br><span class="line"></span><br><span class="line"><span class="comment">//句柄不用的时候一定要用下面的函数关闭(切记：句柄是绝对不会自动释放的),关闭句柄并不会关闭线程</span></span><br><span class="line">raw.closehandle(thrdHandle)</span><br><span class="line">thread.invoke(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"线程在执行"</span>,thread.getId() )   </span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">sleep(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.pause(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>您可以使用 thread.command 在线程间交互通信,请参考<a href="http://bbs.aardio.com/forum.php?mod=viewthread&amp;tid=13121" target="_blank" rel="noopener">《多线程开发入门》</a><br>您还可以使用 thread.event 来实现线程间的同步,请参考<a href="http://bbs.aardio.com/forum.php?mod=viewthread&amp;tid=11531" target="_blank" rel="noopener">《多线程中的交通信号灯：thread.event》</a><br>或者使用 <code>thread.works</code>、<code>thread.manage</code> 这些线程管理器来批量的管理线程句柄,<br>请参考此目录中的其他范例。</p><h3 id="管理多线程"><a href="#管理多线程" class="headerlink" title="管理多线程"></a>管理多线程</h3><p>aardio中提供了 <code>thread.manage</code>，<code>thread.works</code> 等用于管理多个线程的对象，<br>例如标准库中用于实现多线程多任务下载文件的 <code>thread.dlManager</code> 就使用了<code>thread.works</code>管理线程。</p><blockquote><p>thread.works 用于创建多线程任务分派，多个线程执行相同的任务，但可以不停的分派新的任务，</p></blockquote><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> thread.works;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> works = thread.works( <span class="number">20</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">...</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line">        </span><br><span class="line">        thread.lock(<span class="string">"写控制台"</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"线程ID"</span> + thread.getId(),<span class="string">",开始工作,接收到任务指令参数"</span>,...)</span><br><span class="line">        thread.unlock(<span class="string">"写控制台"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"返回值,线程ID"</span> + thread.getId();</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分派任务</span></span><br><span class="line">works.push(<span class="string">"一个任务"</span>)</span><br><span class="line">works.push(<span class="string">"两个任务"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待任务完成</span></span><br><span class="line">works.wait(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"检查成果"</span>, r  )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">works.push(<span class="string">"三个任务"</span>)</span><br><span class="line">works.push(<span class="string">"四个任务"</span>)</span><br><span class="line">works.push(<span class="string">"五个任务"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//退出程序前,等待任务完成并关闭所有线程</span></span><br><span class="line">works.waitClose(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"检查成果"</span>, r  )</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">execute(<span class="string">"pause"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>而 <code>thread.manage</code> 可以用来创建多个线程执行多个不同的任务，可以添加任意个线程启动函数，<br>在线程执行完闭以后可以触发<code>onEnd</code>事件，并且把线程函数的返回值取回来，</p></blockquote><p>示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> thread.manage</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建线程管理器</span></span><br><span class="line">manage = thread.manage(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> thrdFunc = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">import</span> win;</span><br><span class="line">    <span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;<span class="number">10</span>;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( thread.getId(),name )</span><br><span class="line">        <span class="keyword">if</span>( !win.delay(<span class="number">1000</span>) )&#123; <span class="comment">//主线程可以用 manage.quitMessage()中断这个循环</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"收到退出指令"</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">67</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">manage.create(thrdFunc,<span class="string">"线程1"</span>).onEnd = <span class="function"><span class="keyword">function</span>(<span class="params">...</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"线程1的回调"</span>,...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">manage.createLite(thrdFunc,<span class="string">"线程2"</span>).onEnd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"线程2的回调"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">manage.create(thrdFunc,<span class="string">"线程3"</span>)</span><br><span class="line"></span><br><span class="line">manage.waitClose()</span><br><span class="line"><span class="built_in">console</span>.pause();</span><br></pre></td></tr></table></figure><blockquote><p><code>thread.manage</code>通常是用于界面线程里管理工作线程，上面为了简化代码仅仅用到了控制台。</p></blockquote><h3 id="获取线程返回值"><a href="#获取线程返回值" class="headerlink" title="获取线程返回值"></a>获取线程返回值</h3><p>我们有时候在界面中创建一个线程，仅仅是为了让界面不卡顿，我们希望用 <code>thead.waitOne()</code> 阻塞等待线程执行完闭（界面线程同时可以响应消息），然后我们又希望在后面关闭线程句柄，并获取到线程最后返回的值。</p><p>可能我们希望一切尽可能的简单，尽可能的少写代码，并且也不想用到<code>thread.manage</code>（因为并不需要管理多个线程）。</p><p>这时候我们可以使用 <code>win.invoke</code>，<br><code>win.invoke</code> 的参数和用法与 <code>thread.invoke</code>完全一样，<br>区别是 <code>win.invoke</code> 会阻塞并等待线程执行完毕，并关闭线程句柄，同时获取到线程函数的返回值。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win.ui;</span><br><span class="line"><span class="keyword">var</span> winform = win.form(text=<span class="string">"aardio form"</span>;right=<span class="number">759</span>;bottom=<span class="number">469</span>)</span><br><span class="line">winform.add(</span><br><span class="line">    button=&#123;cls=<span class="string">"button"</span>;text=<span class="string">"读取网页"</span>;z=<span class="number">1</span>; ...&#125;;</span><br><span class="line">    edit=&#123;cls=<span class="string">"edit"</span>;text=<span class="string">"edit"</span>;edge=<span class="number">1</span>;multiline=<span class="number">1</span>;z=<span class="number">2</span>; ...&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">winform.button.oncommand = <span class="function"><span class="keyword">function</span>(<span class="params">id,event</span>)</span>&#123;</span><br><span class="line">    winform.edit.text = win.invoke(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">import</span> inet.http;</span><br><span class="line">            sleep(<span class="number">3000</span>);<span class="comment">//暂停模拟一个耗时的操作</span></span><br><span class="line">            <span class="keyword">return</span> inet.http().get(<span class="string">"http://www.aardio.com"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">winform.show()</span><br><span class="line">win.loopMessage();</span><br></pre></td></tr></table></figure><blockquote><p>代码运行测试一下，在线程执行完以前，你仍然可以流畅的拖动窗口，操作界面。</p></blockquote><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><blockquote><p>重视范例，才能开箱即用！</p></blockquote><p>教程中用到的多线程直接调用窗口对象的功能 - 需要更新到新版 aardio才能支持。<br>更多关于多线程的功能请大家看aardio范例和文档。</p><p>一些用户可能不明白 aardio怎样才能真正的“开箱即用”，我接触到的一些用户拿起aardio就可以直接使用，写出非常好的程序而且速度很快，他们高兴的表示aardio简洁轻巧不用特别的学习直接就可以使用，而另外一些却始终在犹豫，在到处找教程、找文档，始终找不到方法，每前进一步都要求你准备一大堆的说明书才敢向前迈一步，实际上我发现他们换其他编程工具也是类似的结果（ 可能有极少数学步车式的开发工具他们会适应 ）。</p><p>我也跟那些上手比较快的用户聊过一些，发现他们都有一个共同的习惯就是非常重视范例，<br>因为 aardio的范例非常、非常的多，而且aardio范例跟其他语言都有一些不同，很多代码就是几句代码就是一个简单而完整的程序，我经常听到一些人跟我说，仅仅是复制一些范例整合到一起，做一些修改就可以做出软件。</p><blockquote><p>所以请记住：教程写的再多，看的再多，始终是纸上谈兵。</p></blockquote><p>搞培训的人很愉快因为能赚到钱，而参加培训的人也很愉快因为找到了心理安慰剂，但真正能让你学会编程的是多看范例，多跑代码，多动手写代码！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当你点击EXE文件系统一个应用程序的时候 - 系统会创建一个进程（process）&lt;br&gt;而在一个进程内可以包含多个线程(thread)。用来显示界面的线程，我们通常称为“界面线程”，&lt;br&gt;其他不是用来显示界面的线程，我们一般称为“工作线程”或者是“后台线程”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="AArdio" scheme="http://suiang.cn/categories/AArdio/"/>
    
    
      <category term="AArdio" scheme="http://suiang.cn/tags/AArdio/"/>
    
  </entry>
  
  <entry>
    <title>AArdio 调用Go语言</title>
    <link href="http://suiang.cn/posts/48288/"/>
    <id>http://suiang.cn/posts/48288/</id>
    <published>2020-09-10T16:59:13.915Z</published>
    <updated>2020-09-10T16:59:13.916Z</updated>
    
    <content type="html"><![CDATA[<p>go语言自带的jsonrpc 不支持http/websocket，而是使用tcp协议，<br>aardio中增加了一个库 wsock.tcp.jsonClient 支持与go语言进行jsonrpc调用。</p><a id="more"></a><p>先使用go语言编写一个exe文件（ 当然你可以把后缀名改为 dll，下面的代码一样可以运行 ）<br>go语言代码如下，注意 go里面{换行写是语法错误 ：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net"</span></span><br><span class="line">    <span class="string">"net/rpc"</span></span><br><span class="line">    <span class="string">"net/rpc/jsonrpc"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">    X, Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> listener net.Listener</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Calculator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Calculator)</span> <span class="title">Add</span><span class="params">(args *Args, reply *<span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    *reply = args.X + args.Y</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Calculator)</span> <span class="title">Exit</span><span class="params">(args *<span class="keyword">int</span>, reply *<span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    listener.Close()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cal := <span class="built_in">new</span>(Calculator)</span><br><span class="line">    server := rpc.NewServer()</span><br><span class="line">    server.Register(cal)</span><br><span class="line"></span><br><span class="line">    listener, e := net.Listen(<span class="string">"tcp"</span>, <span class="string">"localhost:0"</span>)</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"error:%s\n"</span>, e)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, listener.Addr().String())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> conn, err := listener.Accept(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(<span class="string">"error: "</span> + err.Error())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">go</span> server.ServeCodec(jsonrpc.NewServerCodec(conn))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设上面用go语言生成的exe文件名为gotest.exe，并且是放在当前工程目录下，然后我们用下面的 aardio 代码调用这个 gotest.exe 里的go函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win.ui;</span><br><span class="line"><span class="comment">/*DSG&#123;&#123;*/</span></span><br><span class="line"><span class="keyword">var</span> winform = win.form(text=<span class="string">"aardio调用go语言演示"</span>;right=<span class="number">759</span>;bottom=<span class="number">469</span>)</span><br><span class="line">winform.add(</span><br><span class="line">button=&#123;cls=<span class="string">"button"</span>;text=<span class="string">"调用Go语言的Calculator.Add函数"</span>;left=<span class="number">382</span>;top=<span class="number">389</span>;right=<span class="number">678</span>;bottom=<span class="number">427</span>;z=<span class="number">5</span>&#125;;</span><br><span class="line">edit=&#123;cls=<span class="string">"edit"</span>;left=<span class="number">19</span>;top=<span class="number">12</span>;right=<span class="number">732</span>;bottom=<span class="number">352</span>;edge=<span class="number">1</span>;hscroll=<span class="number">1</span>;multiline=<span class="number">1</span>;vscroll=<span class="number">1</span>;z=<span class="number">1</span>&#125;;</span><br><span class="line">editX=&#123;cls=<span class="string">"edit"</span>;text=<span class="string">"2"</span>;left=<span class="number">109</span>;top=<span class="number">392</span>;right=<span class="number">185</span>;bottom=<span class="number">424</span>;edge=<span class="number">1</span>;z=<span class="number">2</span>&#125;;</span><br><span class="line">editY=&#123;cls=<span class="string">"edit"</span>;text=<span class="string">"3"</span>;left=<span class="number">238</span>;top=<span class="number">392</span>;right=<span class="number">320</span>;bottom=<span class="number">420</span>;edge=<span class="number">1</span>;z=<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">static</span>=&#123;cls=<span class="string">"static"</span>;text=<span class="string">"+"</span>;left=<span class="number">198</span>;top=<span class="number">395</span>;right=<span class="number">230</span>;bottom=<span class="number">420</span>;align=<span class="string">"center"</span>;transparent=<span class="number">1</span>;z=<span class="number">4</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">/*&#125;&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wsock.tcp.jsonClient;</span><br><span class="line"><span class="keyword">import</span> process.popen;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gotest.exe是使用go语言编写的exe文件。</span></span><br><span class="line"><span class="keyword">var</span> gofile = process.popen(<span class="string">"/gotest.exe"</span>);</span><br><span class="line"><span class="keyword">if</span>(!gofile) <span class="keyword">return</span> winform.msgbox(<span class="string">"启动go程序失败"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取服务端地址(使用自动分配的空闲端口避免冲突)</span></span><br><span class="line"><span class="keyword">var</span> url = gofile.read();</span><br><span class="line"><span class="keyword">if</span>( !url || string.startWith(url,<span class="string">"error:"</span>)  ) <span class="keyword">return</span> winform.msgbox(<span class="string">"启动go程序失败"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接go语言服务端</span></span><br><span class="line"><span class="keyword">var</span> go = wsock.tcp.jsonClient(url)</span><br><span class="line">winform.edit.print(<span class="string">"已连接到go程序"</span>,url);</span><br><span class="line"></span><br><span class="line">winform.button.oncommand = <span class="function"><span class="keyword">function</span>(<span class="params">id,event</span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//调用go语言提供的函数</span></span><br><span class="line">    <span class="keyword">var</span> rep = go.Calculator.Add(&#123;</span><br><span class="line">        X = tonumber(winform.editX.text);</span><br><span class="line">        Y = tonumber(winform.editY.text);</span><br><span class="line">    &#125; )</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>( rep[[<span class="string">"result"</span>]] )&#123;  </span><br><span class="line">        winform.edit.print( <span class="string">"调用成功"</span>, rep.result )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        winform.edit.print( rep[[<span class="string">"error"</span>]] )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">winform.show()</span><br><span class="line">win.loopMessage();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知go程序退出</span></span><br><span class="line">go.Calculator.Exit(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>附：调用Go语言编译器例子</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> golang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> go = golang();</span><br><span class="line"></span><br><span class="line">go.runCode(<span class="string">"/hello.go"</span>,<span class="string">`</span></span><br><span class="line"><span class="string">package main</span></span><br><span class="line"><span class="string">import "fmt"</span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">    fmt.Println("hello world")</span></span><br><span class="line"><span class="string">&#125;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.pause();</span><br></pre></td></tr></table></figure><p>最新版golang扩展库已支持自动下载配置Go编译器。<br>Go最新版已经支持调用生成DLL文件（需要调用gcc），在aardio中可以直接调用Go生成的DLL文件（使用cdecl调用约定），下面是调用Go编译器生成DLL的演示。  </p><p>下面看演示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> golang;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Go编译器</span></span><br><span class="line"><span class="keyword">var</span> go = golang();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Go源码与字符串都是UTF-8编码，跟aardio一样很方便</span></span><br><span class="line">string.save(<span class="string">"/hello.go"</span>,<span class="string">`</span></span><br><span class="line"><span class="string">package main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import "C"</span></span><br><span class="line"><span class="string">import "fmt"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//export SayHello</span></span><br><span class="line"><span class="string">func SayHello(name string) &#123;</span></span><br><span class="line"><span class="string">    fmt.Printf("Go says: %s!\n", name)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">   //DLL入口函数,没有也要写个空的</span></span><br><span class="line"><span class="string">&#125; `</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译Go源码生成DLL文件</span></span><br><span class="line">go.buildShared(<span class="string">"/hello.go"</span>,<span class="string">"/hello.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载Go编译的DLL，注意要指定cdecl调用约定</span></span><br><span class="line"><span class="keyword">var</span> dll = raw.loadDll(<span class="string">"/hello.dll"</span>,,<span class="string">"cdecl"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接就可以调用DLL里的函数，不用声明</span></span><br><span class="line"><span class="built_in">console</span>.open();</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"必须在Go函数名前面加上 export 函数名的注释才能导出函数"</span>;</span><br><span class="line">dll.SayHello(str,#str);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( n )</span><br><span class="line"><span class="built_in">console</span>.pause();</span><br></pre></td></tr></table></figure><blockquote><p>Go写DLL要注意一个特别的地方，Go导出函数前必须写一行注释声明导出函数，例如上面的 //export SayHello</p></blockquote><p>Go语言里的字符串GoString是一个结构体，用aardio来表示是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goString</span></span>&#123;</span><br><span class="line">    ctor( str )&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = str;</span><br><span class="line">        this.n = #str;</span><br><span class="line">    &#125;;</span><br><span class="line">    string s;</span><br><span class="line">    addr n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是在API函数里传值，一个GoString展开为2个API参数来表示就可以了（一个字符串，后面跟一个字符串长度）</p><p>因为aardio传结构体都是传指针，如果用结构体，在Go里面要声明为指针，示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> golang;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Go编译器</span></span><br><span class="line"><span class="keyword">var</span> go = golang();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Go源码与字符串都是UTF-8编码，跟aardio一样很方便</span></span><br><span class="line">string.save(<span class="string">"/hello.go"</span>,<span class="string">`</span></span><br><span class="line"><span class="string">package main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import "C"</span></span><br><span class="line"><span class="string">import "fmt"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//export SayHello</span></span><br><span class="line"><span class="string">func SayHello(name *string) &#123;</span></span><br><span class="line"><span class="string">    fmt.Printf("Go says: %s!\n", *name)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">func main() &#123;</span></span><br><span class="line"><span class="string">   //DLL入口函数,没有也要写个空的</span></span><br><span class="line"><span class="string">&#125; `</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译Go源码生成DLL文件</span></span><br><span class="line">go.buildShared(<span class="string">"/hello.go"</span>,<span class="string">"/hello.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载Go编译的DLL，注意要指定cdecl调用约定</span></span><br><span class="line"><span class="keyword">var</span> dll = raw.loadDll(<span class="string">"/hello.dll"</span>,,<span class="string">"cdecl"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">goString</span></span>&#123;</span><br><span class="line">    ctor( str )&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = str;</span><br><span class="line">        this.n = #str;</span><br><span class="line">    &#125;;</span><br><span class="line">    string s;</span><br><span class="line">    addr n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接就可以调用DLL里的函数，不用声明</span></span><br><span class="line"><span class="built_in">console</span>.open();</span><br><span class="line">dll.SayHello( goString( <span class="string">"必须在Go函数名前面加上 export 函数名的注释才能导出函数"</span>) );</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( n )</span><br><span class="line"><span class="built_in">console</span>.pause();</span><br></pre></td></tr></table></figure><blockquote><p>需要先安装MinGW( GCC )</p></blockquote><p>可以下载安装 MinGW-W64: <a href="https://sourceforge.net/projects/mingw-w64" target="_blank" rel="noopener">https://sourceforge.net/projects/mingw-w64</a> 这个只能安装在64位系统。<br>也可以下载安装 TDM-GCC: <a href="http://tdm-gcc.tdragon.net/download" target="_blank" rel="noopener">http://tdm-gcc.tdragon.net/download</a> 这个提供支持32位、64位安装包。  </p><p>golang扩展库会自动搜索MinGW,MinGW-W64,TDM-GCC的安装位置，不需要手动配置。<br>当然也可以调用golang扩展库提供的addPath函数自己添加gcc.exe所在的目录。  </p><p>Go生成的文件很大，加上<code>-ldflags &quot;-s -w&quot;</code>参数会小一些，<code>go.buildShared()</code> 已经自动加上这些参数。<br>编译上面的代码生成的DLL只有1MB多一点，而且可以支持WinXP，不需要依赖外部运行库，还是非常不错的。<br>而且测试了一下，编译的DLL还能内存加载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go语言自带的jsonrpc 不支持http/websocket，而是使用tcp协议，&lt;br&gt;aardio中增加了一个库 wsock.tcp.jsonClient 支持与go语言进行jsonrpc调用。&lt;/p&gt;
    
    </summary>
    
      <category term="AArdio" scheme="http://suiang.cn/categories/AArdio/"/>
    
    
      <category term="AArdio" scheme="http://suiang.cn/tags/AArdio/"/>
    
      <category term="Golang" scheme="http://suiang.cn/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>使用 web.rest 调用 REST API</title>
    <link href="http://suiang.cn/posts/11315/"/>
    <id>http://suiang.cn/posts/11315/</id>
    <published>2020-09-10T16:59:13.914Z</published>
    <updated>2020-09-10T16:59:13.915Z</updated>
    
    <content type="html"><![CDATA[<p><code>web.rest</code>下面的支持库最简单的用法就是作为一个 HTTP客户端使用，该客户端对象简化了<code>get</code>,<code>post</code>,<code>put</code>,<code>patch</code>,<code>delete</code> 等常用的 HTTP请求操作，并提供编码请求数据、解码返回数据的功能。</p><a id="more"></a><p>标准库中用于调用 REST API 的库：</p><ul><li><code>web.rest.client</code> 请求参数使用urlencode编码,服务器返回文本数据。</li><li><code>web.rest.xmlClient</code> 请求参数使用urlencode编码,服务器返回xml格式数据。 </li><li><code>web.rest.jsonLiteClient</code> 请求参数使用urlencode编码,服务器返回JSON格式数据。</li><li><code>web.rest.jsonClient</code> 请求参数与服务器返回数据都使用JSON格式。</li></ul><blockquote><p>除了与服务器交互的数据格式不同以外, 这几个库的接口用法完全一样，可以看看这几个库的源码实际上他们都是调用 web.rest.client 这一个库。</p></blockquote><h2 id="基本的-HTTP-请求"><a href="#基本的-HTTP-请求" class="headerlink" title="基本的 HTTP 请求"></a>基本的 HTTP 请求</h2><p>web.rest下面的支持库最简单的用法就是作为一个HTTP客户端使用，该客户端对象简化了<code>get</code>,<code>post</code>,<code>put</code>,<code>patch</code>,<code>delete</code>等常用的HTTP请求操作，并提供编码请求数据、解码返回数据的功能，下面是一个最简单的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> web.rest.jsonLiteClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> restClient = web.rest.jsonLiteClient();</span><br><span class="line"><span class="keyword">var</span> jsonData = restClient.post(<span class="string">"http://httpbin.org/post"</span>, &#123;</span><br><span class="line">    用户名 = <span class="string">"用户名"</span>;</span><br><span class="line">    密码 = <span class="string">"密码"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dumpJson(jsonData)</span><br><span class="line"><span class="built_in">console</span>.pause(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>从上面的示例可以看出，我们上传参数的是<code>aardio</code>中的对象，返回的数据也被自动解码为<code>aardio</code>对象，虽然 HTTP传输使用的是 <code>JSON</code> 数据，但使用时不需要去管 <code>JSON</code> 的编解码等一系列的操作。</p><h2 id="转换为-AArdio-函数"><a href="#转换为-AArdio-函数" class="headerlink" title="转换为 AArdio 函数"></a>转换为 AArdio 函数</h2><p><code>web.rest</code> 不仅仅可以用来做上面这些简单的 HTTP请求、以及编解码的操作，他还可以将基本符合 REST风格的 Web API转换为<code>aardio</code>中的函数对象，这非常有意思，REST本身不是一个严格的规范、更缺乏<code>WebService</code>那样的<code>WSDL</code>接口描述服务，但是<code>aardio</code>设计了一种简单可行的声明语法，可以非常方便的把混乱的 Web API转换为统一的 aardio函数。</p><p>首先我们看一下 REST API的 URL 一般会是这种格式 <a href="#">http://主机/资源目录名/资源目录名/资源名</a><br><code>aardio</code>的<code>web.rest</code>库模块中的客户端对象提供一个 api 函数用于声明一个API接口，api 函数的定义如下：</p><p><code>var restApi = restClient.api(&quot;接口URL描述&quot;,&quot;默认HTTP请求动词&quot;)</code></p><p>其中接口URL描述可以直接指定一个web api的网址，在该网址中还可以使用变量，变量放在花括号中，例如：<a href="#">http://主机/{变量名}/资源目录名/资源名</a> <code>aardio</code>并不关心变量名的内容是什么，只关心它们出现的前后顺序，当调用<code>restApi</code>的成员函数时会使用函数名替换接口 URL 中的变量生成新的请求URL。</p><p>下面是一个简单的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> web.rest.jsonClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建REST客户端</span></span><br><span class="line"><span class="keyword">var</span> restClient = web.rest.jsonClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个API接口,第一个参数指定URL描述</span></span><br><span class="line"><span class="keyword">var</span> restApi = restClient.api(<span class="string">"http://httpbin.org/api/&#123;program&#125;/&#123;lang&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">下面调用接口函数，</span></span><br><span class="line"><span class="comment">在请求时下面代码中的接口名"language"替换接口URL描述中的变量&#123;program&#125;</span></span><br><span class="line"><span class="comment">接口名"aardio"则替换接口URL描述中的变量&#123;lang&#125;</span></span><br><span class="line"><span class="comment">最后生成的请求URL为 http://httpbin.org/api/language/aardio </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> result = restApi.language.aardio()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"请求的URL"</span>, restClient.lastRequestUrl)</span><br><span class="line">restClient.lastResponse(); <span class="comment">//输出服务端最后返回的数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.pause();</span><br></pre></td></tr></table></figure></p><p>接口 URL中连接的变量名还可以合并为<code>{...}</code><br>例如  <code>http://httpbin.org/api/{program}/{lang}</code> 可以简写为 <code>http://httpbin.org/api/{...}</code><br>当 <code>{...}</code> 出现在尾部时还可以直接省略，例如 <code>http://httpbin.org/api/</code></p><blockquote><p>注意head,get,post,put,patch,delete等默认的HTTP请求操作作为函数名时不会被添加到生成的URL中。</p></blockquote><p>这些默认的HTTP方法名在 <code>web.rest.client._defaultMethod</code> 中指定，例如使用 <code>restApi.language.get()</code> 显示的指定 HTTP请求动词为<code>GET</code>。如果不指定 HTTP请求动词，则使用调用 <code>restClient.api(&quot;接口URL描述&quot;,&quot;默认HTTP请求动词&quot;)</code> 函数时第二个参数指定的 HTTP请求动词，不指定该参数时默认为<code>POST</code>。</p><p>HTTP规定了九种动词<code>（Verbs）</code>用于指定请求方法：<code>GET</code>,<code>HEAD</code>,<code>POST</code>,<code>DEBUG</code>,<code>PUT</code>,<code>DELETE</code>,<code>PATCH</code>,<code>OPTIONS</code>，<br>而在<code>REST API中</code>用到的有五种 <code>GET</code>，<code>POST</code>，<code>PUT</code>，<code>DELETE</code>，<code>PATCH</code>，他们的用途如下：</p><ul><li><code>GET</code>：用于获取数据</li><li><code>POST</code>:  用于创建数据 </li><li><code>PUT</code>: 用于替换数据、也可用于更新数据</li><li><code>DELETE</code>: 用于删除数据</li><li><code>PATCH</code>：用于更新数据</li></ul><h2 id="上传下载文件"><a href="#上传下载文件" class="headerlink" title="上传下载文件"></a>上传下载文件</h2><p>如果一个REST API在请求时需要上传、下载文件，那么所有调用规则如前不变。<br>你仅仅需要做的是，在调用API以前指定接受、或发送文件的回调函数以获取上传、下载的进度。</p><p>上传文件示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">restClient.sendFile( <span class="string">"上传文件路径"</span> </span><br><span class="line">    ,<span class="function"><span class="keyword">function</span>(<span class="params">str,sendSize,contentLength</span>)</span>&#123;</span><br><span class="line">        ..io.print(<span class="string">"正在上传"</span>,sendSize,contentLength);</span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="comment">//在后面再简单的调用API就可以了，例如</span></span><br><span class="line">restApi.upload()</span><br></pre></td></tr></table></figure><p>下载文件示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">restClient.receiveFile( <span class="string">"上传文件路径"</span> </span><br><span class="line">    , <span class="function"><span class="keyword">function</span>(<span class="params">str,receiveSize,contentLength</span>)</span>&#123;</span><br><span class="line">        ..io.print(<span class="string">"正在下载"</span>,receiveSize,contentLength);</span><br><span class="line">    &#125;</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="comment">//在后面再简单的调用API就可以了，例如</span></span><br><span class="line">restApi.download()</span><br></pre></td></tr></table></figure><p><code>web.rest</code> 也可以支持 <code>multipart/form-data</code> 编码上传文件，示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>; </span><br><span class="line"><span class="keyword">import</span> web.rest.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = web.rest.client(); </span><br><span class="line">http.sendMultipartForm( &#123;</span><br><span class="line">        file = <span class="string">"@d:\文件路径"</span>; </span><br><span class="line">        username = <span class="string">"测试"</span>;</span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span>(<span class="params">str,sendSize,contentLength</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"正在上传"</span>,sendSize,contentLength);</span><br><span class="line">    &#125; </span><br><span class="line">);</span><br><span class="line"><span class="keyword">var</span> str =http.post(<span class="string">"http://httpbin.org/post"</span>) </span><br><span class="line"><span class="built_in">console</span>.pause(,str)</span><br></pre></td></tr></table></figure><h2 id="客户端对象的错误处理"><a href="#客户端对象的错误处理" class="headerlink" title="客户端对象的错误处理"></a>客户端对象的错误处理</h2><p><code>web.rest</code> 客户端对象的错误处理与<code>inet.http</code>相同：<br>请求成功返回服务器数据，失败返回空值,错误信息，错误代码等。</p><blockquote><p>注意下面为了演示所有的细节，代码写的比较长，实际开发中不必要写的这么细</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> web.rest.jsonLiteClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> restClient = web.rest.jsonLiteClient();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">web.rest客户端对象所以执行HTTP请求的函数遵守以下规则：</span></span><br><span class="line"><span class="comment">如果成功:</span></span><br><span class="line"><span class="comment">则第一个返回值jsonData为服务端返回数据解码并创建的aardio对象。</span></span><br><span class="line"><span class="comment">在HTTP请求遇到错误时:</span></span><br><span class="line"><span class="comment">第一个返回值jsonData为空，</span></span><br><span class="line"><span class="comment">第二个返回值errMsg为错误信息,</span></span><br><span class="line"><span class="comment">返回值errCode为错误代码</span></span><br><span class="line"><span class="comment">一般我们可以省略errMsg，errCode这两个返回值不用写，</span></span><br><span class="line"><span class="comment">直接判断返回值是否为空即可。  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonData, errMsg, errCode = restClient.post(<span class="string">"http://httpbin.org/post"</span>, &#123;</span><br><span class="line">    用户名 = <span class="string">"用户名"</span>;</span><br><span class="line">    密码 = <span class="string">"密码"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//jsonData非空为请求成功</span></span><br><span class="line"><span class="keyword">if</span> (jsonData) &#123;</span><br><span class="line">    <span class="built_in">console</span>.dumpJson(jsonData);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    出错了，如果restClient.lastStatusCode非空则说明服务端返回了HTTP状态代码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (restClient.lastStatusCode) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(restClient.lastStatusMessage()) <span class="comment">//查看该状态码的说明</span></span><br><span class="line">        restClient.lastResponse() <span class="comment">//输出服务端最后返回的信息</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//这通常是没有成功发送请求，在请求到达服务器以前就出错了</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"HTTP请求遇到错误,WinInet错误代码："</span>, errCode)</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">'关于WinInet错误代码的详细说明：\n</span></span><br><span class="line"><span class="string">            http: //support.microsoft.com/kb/193625'</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.pause();</span><br></pre></td></tr></table></figure><p>当然上面的代码一般在调试故障时才需要，一般没必要把错误处理写的这么细，上面的代码也可以简化如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> web.rest.jsonLiteClient;</span><br><span class="line"><span class="keyword">var</span> restClient = web.rest.jsonLiteClient();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> 鸭子 = restClient.post(<span class="string">"http://httpbin.org/post"</span>, &#123;</span><br><span class="line">    用户名 = <span class="string">"用户名"</span>;</span><br><span class="line">    密码 = <span class="string">"密码"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (鸭子[[<span class="string">"翅膀"</span>]]) &#123; <span class="comment">//这句相当于 if( 鸭子 and 鸭子.翅膀 )</span></span><br><span class="line">    io.print(<span class="string">"不管服务器给我的是什么鸭子，总之有翅膀的都是好鸭子"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    我的网络错误处理模块.错误统一分析(</span></span><br><span class="line"><span class="comment">    "怎么回事没翅膀还能叫鸭子吗？"</span></span><br><span class="line"><span class="comment">    , restClient.lastStatusCode )</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>, <span class="string">"网络错误"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端接口设计原则"><a href="#服务端接口设计原则" class="headerlink" title="服务端接口设计原则"></a>服务端接口设计原则</h2><p>本文参考了 REST API的设计风格、但有部分规则有所变通。在实践中 REST API 完全符合REST规则的比较少见，我在设计 web.rest.client 试图编写一个尽可能通用的支持库、但是发现REST API的实现真是五花八门，而且也缺乏一个统一的接口描述规则。 </p><p>如果你需要为你的aardio客户端程序设计自己的Web API，那么参考下面的几条原则去实现服务端接口 - 这可以让标准库里 web.rest.client 方便的支持该API( 请参考：<a href="http://bbs.aardio.com/forum.php?mod=viewthread&amp;tid=11218" target="_blank" rel="noopener">使用 web.rest 调用 REST API</a>  ).</p><h3 id="资源定位路径"><a href="#资源定位路径" class="headerlink" title="资源定位路径"></a>资源定位路径</h3><p>URL应用于清晰的展现资源定位路径，目录应当使用清晰的资源名称，并可以使用统一的URL接口描述语法声明该API。</p><p>例如：<a href="#">http://主机/资源分类/资源目录/资源名/资源ID</a> 原则上不应当把资源名放在URL参数里，</p><p>但是要使用这样的友好URL在现实中是用一定代价的，对于一般的Web服务器这可能需URL重写,有一定的性能负担。所以也可以将资源名放到URL参数里，例如 <a href="#">HTTP://主机/资源分类?资源目录=目录名&amp;资源名=资源名&amp;资源ID=资源ID</a> 要注意这里的资源定位有关的参数应当直接放到URL的参数里也就是?号后面，要将资源定位的参数与HTTP提交的参数分开来( 如果你用过 <code>web.rest.client</code> 就知道为什么要这样做 )，并且要按资源定位关系决定参数出现的先后关系。</p><p>最后生成的URL要能使用以下的URL描述规则:<br>URL中的资源名应当能使用<code>{模板变量}</code>代替、<code>{模板变量}</code>的先后关系应当对应资源名的出现顺序。<code>{模板变量}</code>包含在花括号里 - 可以使用多个数字或字母，数值的大小并不重要，URL描述仅关心资源出现的先后关系。可以使用 <code>{...}</code> 表示不定个数的模板变量。</p><p><a href="#">http://主机/资源分类/资源目录/资源名/资源ID</a> 使用URL描述语法转换结果就是这样： <a href="#">http://主机/{res}/{category}/{name/{id}</a> 也可以使用 <a href="#">http://主机/{res}/{…}</a> 表示。如果 <code>{...}</code> 出现在最后则可以省略</p><p><a href="#">HTTP://主机/资源分类?资源目录=目录名&amp;资源名=资源名&amp;资源ID=资源ID</a><br>使用URL描述语法转换以后： <a href="#">HTTP://主机/{res}?资源目录={category}&amp;资源名={name}&amp;资源ID={id}</a></p><p>可以看到资源名是不是写到参数里都能清晰的展现资源定位，要注意 Web API 并不是浏览器，URL并不会出现在浏览器的地址栏，设计一个友好的 API URL 重要的是编程语言里能不能更好的理解并自动分析转换。 例如<code>aardio</code>中的 <code>web.rest.client</code> 就按照这种 URL 描述语法自动的将 URL 描述转换为<code>aardio</code>中的函数对象。</p><h3 id="不包含动词"><a href="#不包含动词" class="headerlink" title="不包含动词"></a>不包含动词</h3><p>原则上URL不应当包含动词，使用HTTP协议的指令动词表示要执行的操作:</p><blockquote><p>GET: 表示获取资源<br>POST: 表示新增数据<br>PUT: 表示替换数据<br>DELETE: 表示删除数据<br>PATCH: 表示更新数据</p></blockquote><p>一般的Web服务器因为安全方面的考虑对HEAD、GET、POST之外的请求有所限制, 很多API用POST替代PUT,DELETE的功能，而又要做到URL中不出现动词，就背离了REST的初衷了。</p><p>因此建议可选在URL资源定位的最可选性的添加扩展的操作动词，例如：<br><a href="#">http://host/group/user/userid/</a> 使用get读取用户信息<br><a href="#">http://host/group/user/userid/password/change</a> 使用扩展的change方法修改用户密码</p><p>如果按这种规则实现服务端的API，那么在aardio里用 web.rest.client 调用起来就很方便，示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> web.rest.jsonClient;</span><br><span class="line"><span class="keyword">var</span> client = web.rest.jsonClient()</span><br><span class="line"><span class="keyword">var</span> api = client.api(<span class="string">"http://host/&#123;group&#125;/&#123;..&#125;"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GET方法读取用户信息</span></span><br><span class="line"><span class="keyword">var</span> userInfo = api.xgroup.user[userId].get()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展的change方法修改密码</span></span><br><span class="line">api.xgroup.user[userId].passord.change(</span><br><span class="line">    pwd = <span class="string">"旧密码"</span>; </span><br><span class="line">    newPwd = <span class="string">"新密码"</span>;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>为什么不直接在每一个请求里写具体的URL呢？要考虑到实现一个API的扩展库，API服务端的地址可能发生变更，使用上面的方法就可以简单的维护一个声明URL参数即可。</p><h3 id="不出现文件后缀名"><a href="#不出现文件后缀名" class="headerlink" title="不出现文件后缀名"></a>不出现文件后缀名</h3><p>Web API 的URL中不应出现文件后缀名：<br>例如： <a href="#">http://host/x/y.php</a> 应当在服务器上移动到 <a href="#">http://host/x/y/index.php</a> ，然后提供给客户端的API应隐藏默认的文档名，即 <a href="#">http://host/x/y/</a> 这样的好处是服务端变更实现会非常方便。</p><h3 id="不出现-IP-地址"><a href="#不出现-IP-地址" class="headerlink" title="不出现 IP 地址"></a>不出现 IP 地址</h3><p>Web API 的URL中不应出现IP地址，即使是测试期间，也应尽可能的使用域名替代IP地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;web.rest&lt;/code&gt;下面的支持库最简单的用法就是作为一个 HTTP客户端使用，该客户端对象简化了&lt;code&gt;get&lt;/code&gt;,&lt;code&gt;post&lt;/code&gt;,&lt;code&gt;put&lt;/code&gt;,&lt;code&gt;patch&lt;/code&gt;,&lt;code&gt;delete&lt;/code&gt; 等常用的 HTTP请求操作，并提供编码请求数据、解码返回数据的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="AArdio" scheme="http://suiang.cn/categories/AArdio/"/>
    
    
      <category term="AArdio" scheme="http://suiang.cn/tags/AArdio/"/>
    
      <category term="Web" scheme="http://suiang.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>使用 GitHub 搭建个人博客</title>
    <link href="http://suiang.cn/posts/48270/"/>
    <id>http://suiang.cn/posts/48270/</id>
    <published>2020-09-10T16:59:13.908Z</published>
    <updated>2020-09-10T16:59:13.910Z</updated>
    
    <content type="html"><![CDATA[<p> <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo</a> , 一个简单地、轻量地、基于 Node 的一个静态博客框架。下面介绍下如何使用 hexo 和 github pages 搭建个人博客。</p> <a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><blockquote><p>注意：本文针对Windows平台和Hexo 3.2.2</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line">hexo: 3.2.2</span><br><span class="line">hexo-cli: 1.0.2</span><br><span class="line">os: Windows_NT 10.0.14393 win32 x64</span><br><span class="line">http_parser: 2.7.0</span><br><span class="line">node: 6.10.1</span><br></pre></td></tr></table></figure><h3 id="安装-Github-For-Windows"><a href="#安装-Github-For-Windows" class="headerlink" title="安装 Github For Windows"></a>安装 Github For Windows</h3><p>主要使用 git bash，如果对 git 命令不熟悉的也可以使用 git 客户端进行某些操作<br><a href="https://windows.github.com/" target="_blank" rel="noopener">Github For Windows</a></p><h3 id="安装-node-js"><a href="#安装-node-js" class="headerlink" title="安装 node.js"></a>安装 node.js</h3><p>因为要使用 npm，比较简单的方法就是安装 <a href="http://nodejs.org/" target="_blank" rel="noopener">node.js</a></p><blockquote><p>安装完成后添加 Path 环境变量，使 npm 命令生效<br><code>;C:\Program Files\nodejs\node_modules\npm</code></p></blockquote><h3 id="创建-Github-Pages"><a href="#创建-Github-Pages" class="headerlink" title="创建 Github Pages"></a>创建 Github Pages</h3><p>没有Github 账号的话，需要注册一个，然后创建一个仓库，名字是<br><code>[yourGithubAccount].github.io</code></p><h3 id="配置-ssh-key"><a href="#配置-ssh-key" class="headerlink" title="配置 ssh key"></a>配置 ssh key</h3><p>使用 <code>git bash</code> 生成 <code>public ssh key</code>, 以下是最简单的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>然后在 <code>C:\Users\[用户名]\.ssh</code> 目录下会生成 <code>id_rsa.pub</code> ，将内容完全复制到 <code>Github Account Setting</code> 里的 <code>ssh key</code> 粘贴即可。</p><p><strong>测试</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi [yourGithubAccount]! You&apos;ve successfully authenticated,</span><br><span class="line">but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><p><strong>设置用户信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;[yourName]&quot;//用户名</span><br><span class="line">$ git config --global user.email  &quot;[yourEmail]&quot;//填写自己的邮箱</span><br></pre></td></tr></table></figure><blockquote><p>经过以上步骤，本机已成功连接到 github，为部署打下基础。</p></blockquote><hr><h2 id="配置-Hexo"><a href="#配置-Hexo" class="headerlink" title="配置 Hexo"></a>配置 Hexo</h2><h3 id="本地-clone"><a href="#本地-clone" class="headerlink" title="本地 clone"></a>本地 clone</h3><p>创建本地目录，然后使用 git bash 或者客户端 clone 之前创建的仓库<br><code>[yourGithubAccount].github.io</code></p><h3 id="安装、配置-Hexo"><a href="#安装、配置-Hexo" class="headerlink" title="安装、配置 Hexo"></a>安装、配置 Hexo</h3><p>进入仓库目录，使用 <code>npm</code> 安装配置 <code>hexo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ npm install hexo --save</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p><strong>安装 Hexo 插件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure><blockquote><p>安装 <code>ejs</code>， 否则无法解析模板</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install ejs</span><br></pre></td></tr></table></figure><p>安装 hexo 所需的依赖模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>然后运行下面的命令生成 public 文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><blockquote><p>在浏览器输入 <code>localhost:4000</code> 本地查看效果</p></blockquote><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>hexo 有很多主题可选，我选了 <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">indigo</a>，Material Design 风格的Hexo主题，基于 Hexo 3.0+ 制作。支持多说评论、网站统计、分享等功能，只要稍微配置即可使用。可以根据自己需求进行选择。</p><hr><h2 id="使用-hexo"><a href="#使用-hexo" class="headerlink" title="使用 hexo"></a>使用 hexo</h2><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>配置 <code>_config.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:[yourGithubAccount]/[yourGithubAccount].github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>即可将 hexo 部署到 github 上</p><blockquote><p>提示找不到 git 时</p></blockquote><p>需执行（虽然之前已经执行过）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>即可访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://[yourGithubAccount].github.io/</span><br></pre></td></tr></table></figure></p><h3 id="发表新文章"><a href="#发表新文章" class="headerlink" title="发表新文章"></a>发表新文章</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure><p>然后在 <code>source/_post</code> 下会生成该.md文件，即可使用编辑器编写了编写过程中，可以在本地实时查看效果，很是方便。支持 <code>markdown</code>，不了解的自行 <a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a> 。</p><p>编写完成后，部署还是一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><p>如果部署过程中报错，可执行以下命令重新部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="添加自定义页面"><a href="#添加自定义页面" class="headerlink" title="添加自定义页面"></a>添加自定义页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure><p>该命令会生成 <code>source/about/index.md</code>，编辑即可</p><h3 id="插件的升级与卸载"><a href="#插件的升级与卸载" class="headerlink" title="插件的升级与卸载"></a>插件的升级与卸载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm update</span><br><span class="line">$ npm uninstall &lt;plugin-name&gt;</span><br></pre></td></tr></table></figure><h3 id="更新-hexo"><a href="#更新-hexo" class="headerlink" title="更新 hexo"></a>更新 hexo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update -g hexo</span><br></pre></td></tr></table></figure><h3 id="绑定自定义域名"><a href="#绑定自定义域名" class="headerlink" title="绑定自定义域名"></a>绑定自定义域名</h3><p>在 <code>/source/</code> 目录下新建内容为自定义域名的 <code>CNAME</code> 文件，部署即可（域名设置略）</p><blockquote><p>备注：Hexo简写命令</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n #new</span><br><span class="line">hexo g #generate</span><br><span class="line">hexo s #server</span><br><span class="line">hexo d #deploy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; , 一个简单地、轻量地、基于 Node 的一个静态博客框架。下面介绍下如何使用 hexo 和 github pages 搭建个人博客。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://suiang.cn/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://suiang.cn/tags/Hexo/"/>
    
      <category term="Github" scheme="http://suiang.cn/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>不声明直接调用 API 函数</title>
    <link href="http://suiang.cn/posts/35919/"/>
    <id>http://suiang.cn/posts/35919/</id>
    <published>2020-09-10T16:59:13.907Z</published>
    <updated>2020-09-10T16:59:13.907Z</updated>
    
    <content type="html"><![CDATA[<p>一般建议不要先声明API再去调用，直接调用更方便也更节省资源(除非有特殊的数据类型必须通过声明API来指定)。</p><a id="more"></a><p>示例： </p><p> <code>::User32.MessageBox(0,&quot;测试&quot;,&quot;标题&quot;,0)</code></p><h2 id="添加参数的规则"><a href="#添加参数的规则" class="headerlink" title="添加参数的规则"></a>添加参数的规则</h2><ol><li><p>调用约定在加载DLL的参数中指定,支持cdecl不定个数参数,有很多API根据不同的用法可以传入不同类型的参数， 如果我们在aardio中不是先写一个API声明，而是直接去调用API，这时候就可以根据需要更灵活的改变参数类型。一般建议不要先声明API再去调用 - 直接调用更方便也更节省资源(除非有特殊的数据类型必须通过声明API来指定)。 </p></li><li><p>null参数不可省略 </p></li><li><p>数值参数一律处理为32位int整型，32位整数类型，小于32位的整数、枚举类型、8位或32位bool值都跟int 32位数值兼容，可以直接写在参数里,示例：</p></li></ol><blockquote><p>32位整型以及小于32位的整型参数都可以直接传入aardio数值。<br>例如C语言API声明为：<code>void setNumber( short n )</code><br>在aardio里如下调用就可以 <code>dll.setNumber( 123 )</code></p></blockquote><ol start="4"><li><p>64位整数（C语言中的long long)可以math.size64对象表示，或者用两个数值参数表示一个64位整数值参数，其中第一个参数表示低32位数值,第二个参数表示高32位数值（一般可以直接写0）。 </p></li><li><p>对于任何数值类型的指针（输出参数）一律使用结构体表示，<br>例如C语言API声明为：<code>void getNumber( short *n )</code> 在aardio里如下调用就可以</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = &#123; word value &#125;</span><br><span class="line">dll.getNumber(n)</span><br></pre></td></tr></table></figure><ol start="6"><li><p>API函数中的数组指针，在<code>aardio</code>中可以使用结构体指针替代，例如C语言中的 <code>int data[4];</code> 在aardio中写为 <code>{int data[4];}</code> 如果是字节数组指针也可以使用<code>raw.buffer()</code>函数创建的字节数组替代。 </p></li><li><p>所有结构体一律处理为输出参数并在<code>aardio</code>返回值中返回，其他类型只能作为输入参数。注意在<code>aardio</code>中，任何结构体在API调用中传递的都是结构体指针（传址）。 </p></li><li><p>因为没有参数类型声明，调用代码有责任事先检查并保证参数类型正确，传入错误的参数可能导致程序异常。 </p></li></ol><h2 id="获取返回值的规则"><a href="#获取返回值的规则" class="headerlink" title="获取返回值的规则"></a>获取返回值的规则</h2><ol><li><p>直接调用API的 返回值默认为<code>int</code>类型 </p></li><li><p>可以使用<code>[API尾标]</code>改变返回值为其他类型 </p></li><li><p>未声明的 API函数自身在<code>aardio</code>中是一个普通的<code>aardio</code>函数对象，不能作为函数指针参数传给 API参数（声明后的API函数对象是可以的） </p></li></ol><h2 id="使用-API-尾标"><a href="#使用-API-尾标" class="headerlink" title="使用 [ API 尾标 ]"></a>使用 [ API 尾标 ]</h2><p>当不声明直接调用API时，API函数名尾部如果不是大写字符，则可以使用一个大写的特定字符（API尾标）修改默认的API调用规则，在API函数名后添加尾标，不会影响到查找API函数的结果，无论真实的API带不带指定的尾标 - aardio都能找到真实的函数。 所有可用的[API尾标]如下（函数名的最后一个特定字符是尾标）：</p><blockquote><p><code>dll.ApiNameW()</code> 切换到<code>Unicode</code>版本，字符串<code>UTF8</code><-><code>UTF16</code>双向转换<br><code>dll.ApiNameA()</code> 切换到<code>ANSI</code>版本,字符串不作任何转换<br><code>dll.ApiNameL()</code> 返回值为64位<code>LONG</code>类型<br><code>dll.ApiNameP()</code> 返回值为指针类型<br><code>dll.ApiNameD()</code> 返回值为<code>double</code>浮点数<br><code>dll.ApiNameF()</code> 返回值为<code>float</code>浮点数<br><code>dll.ApiNameB()</code> 返回值为 C++ 中的8位<code>bool</code>类型</-></p></blockquote><h2 id="如何使用字符串"><a href="#如何使用字符串" class="headerlink" title="如何使用字符串"></a>如何使用字符串</h2><ol><li><p>字符串一般直接转换为字符串指针，<code>buffer</code>类型字节数组也可以作为字符串指针使用，如果API需要向字符串指向的内存中写入数据，那么必须使用<code>raw.buffer()</code>函数创建定长的字节数组。普通的<code>aardio</code>字符串指向的内存是禁止写入的（<code>aardio</code>中修改普通字符串会返回新的字符串对象，而不是在原内存上修改数据） </p></li><li><p>对于非<code>Unicode</code> API字符串直接输入原始的数据（对于文本就是UTF8编码），对于声明为<code>Unicode</code>版本的API，字符串会被强制转换为<code>Unicode(UTF16)</code>，但<code>buffer</code>类型的参数仍然会以二进制方式使用原始数据与API交互（不会做文本编码转换）</p><ul><li><p>可以在 <code>raw.loadDll()</code> 加载 DLL时在调用约定中添加<code>,unicode</code>声明一个 DLL默认使用<code>Unicode API</code>。</p></li><li><p>也可以在函数名后添加尾标 <code>W</code> 声明一个<code>Unicode API</code>, 即使真实的API函数名后面并没有 <code>W</code> 尾标，你仍然可以添加 <code>W</code> 尾标调用 API。<code>aardio</code>在找不到该 API函数时，会移除 <code>W</code> 尾标，并且认为该 API函数是一个<code>Unicode API</code>，注意 <code>W</code> 必须大写并紧跟在小写字母后面。</p></li><li><p>直接调用 API时，如果目标 API函数并不存在，而是存在加 <code>W</code> 尾标的<code>Unicode API</code>,<code>aardio</code>将会自动切换到<code>Unicode API</code>，并在调用函数时，自动将<code>aardio</code>的<code>UTF8</code>编码转换为 API所需要的<code>UTF16</code>编码。</p></li><li><p>反之，在API函数名后也可以显式的添加 <code>A</code> 尾标强制声明此 API是一个 <code>ANSI</code> 版本的函数（对字符串参数不使用任何 <code>Unicode</code> 转换，即使加载 DLL时在调用约定中声明了默认以 <code>unicode</code> 方式调用），规则同上 - 也即真实的API函数名后面有没有 <code>A</code> 尾标并不重要，在<code>aardio</code>中都可以加上 <code>A</code> 尾标。 </p></li></ul></li><li><p>一些API在接收字符串、字节数组等参数时，通常下一个参数需要指定内存长度， <code>aardio</code>中用<code>#</code>操作符取字符串、缓冲区的长度时，返回的都是字节长度，一些 API可能需要你传入字符个数， 发果是<code>Unicode</code>版本的 API一个字符为两个字节，对于一个<code>UTF8</code>字符串应当事用<code>string.len()</code>函数得到真正的字符长度, 而<code>Unicode</code>字符串则用<code>#</code>取到字节长度后乘以2即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般建议不要先声明API再去调用，直接调用更方便也更节省资源(除非有特殊的数据类型必须通过声明API来指定)。&lt;/p&gt;
    
    </summary>
    
      <category term="AArdio" scheme="http://suiang.cn/categories/AArdio/"/>
    
    
      <category term="AArdio" scheme="http://suiang.cn/tags/AArdio/"/>
    
      <category term="API" scheme="http://suiang.cn/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Hello World！</title>
    <link href="http://suiang.cn/posts/16107/"/>
    <id>http://suiang.cn/posts/16107/</id>
    <published>2020-09-10T16:59:13.904Z</published>
    <updated>2020-09-10T16:59:13.905Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎使用 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> ! 这是你的第一篇文章。检查 <a href="https://hexo.io/docs/" target="_blank" rel="noopener">文档</a> 以获取更多信息。如果你在使用Hexo时遇到任何问题，你可以在  <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">故障排除</a> 中找到答案，或者你可以在 <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a> 提问。</p><a id="more"></a><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建新帖子"><a href="#创建新帖子" class="headerlink" title="创建新帖子"></a>创建新帖子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>更多信息: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎使用 &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; ! 这是你的第一篇文章。检查 &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文档&lt;/a&gt; 以获取更多信息。如果你在使用Hexo时遇到任何问题，你可以在  &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;故障排除&lt;/a&gt; 中找到答案，或者你可以在 &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt; 提问。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://suiang.cn/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://suiang.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>WebDriver 协议客户端</title>
    <link href="http://suiang.cn/posts/39047/"/>
    <id>http://suiang.cn/posts/39047/</id>
    <published>2020-09-10T16:59:13.903Z</published>
    <updated>2020-09-10T16:59:13.903Z</updated>
    
    <content type="html"><![CDATA[<p>WebDriver 是用于控制浏览器的一个协议，<br>我们试试用 aardio 来实现这个功能，我们只需要浏览器提供的接口。</p><a id="more"></a><p>例如 chromeDriver.exe （ 不同版本的chrome要下载不同版本的 chromeDriver.exe ）。其他的东西我们就不需要了，安装这个安装那个多麻烦对吗？！  </p><p>看一下其他语言的封装库，代码可能很多，但是不要被吓倒了，用 aardio 我们真的只要几句代码就可以实现 WebDriver 客户端了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> web.rest.jsonClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协议文档 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol</span></span><br><span class="line"><span class="keyword">var</span> http = web.rest.jsonClient();</span><br><span class="line"><span class="keyword">var</span> webDriver = http.api(<span class="string">"http://localhost:9515/"</span>);<span class="comment">//改成chromedriver的实际端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建会话，打开chrome浏览器</span></span><br><span class="line"><span class="keyword">var</span> chrome = webDriver.session(</span><br><span class="line">    desiredCapabilities = &#123;</span><br><span class="line">        browserName = <span class="string">"chrome"</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取打开的浏览器会话</span></span><br><span class="line"><span class="keyword">var</span> session = webDriver.session[chrome.sessionId];</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开网页</span></span><br><span class="line">session.url(</span><br><span class="line">    url = <span class="string">"http://www.baidu.com"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找百度输入框</span></span><br><span class="line"><span class="keyword">var</span> ele = session.element(</span><br><span class="line">    using = <span class="string">"id"</span>;</span><br><span class="line">    value = <span class="string">"kw"</span>;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//在网页输入框输入内容</span></span><br><span class="line">session.element[ ele.value.ELEMENT ].value(</span><br><span class="line">    value = &#123; <span class="string">"ChromeDriver"</span> &#125;;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;WebDriver 是用于控制浏览器的一个协议，&lt;br&gt;我们试试用 aardio 来实现这个功能，我们只需要浏览器提供的接口。&lt;/p&gt;
    
    </summary>
    
      <category term="AArdio" scheme="http://suiang.cn/categories/AArdio/"/>
    
    
      <category term="AArdio" scheme="http://suiang.cn/tags/AArdio/"/>
    
      <category term="Chrome" scheme="http://suiang.cn/tags/Chrome/"/>
    
      <category term="WebDriver" scheme="http://suiang.cn/tags/WebDriver/"/>
    
  </entry>
  
  <entry>
    <title>Chrome 系列范例</title>
    <link href="http://suiang.cn/posts/57740/"/>
    <id>http://suiang.cn/posts/57740/</id>
    <published>2020-09-10T16:59:13.901Z</published>
    <updated>2020-09-10T16:59:13.902Z</updated>
    
    <content type="html"><![CDATA[<p>大家知道Chrome每个版本的适用ChromeDriver版本都不一样，<br>安装不同的Chrome就要去下载不同的ChromeDriver.exe，而且还要命令行启动，绑定固定端口一搞不好还会跟别的进程冲突了。</p><a id="more"></a><p>现在用aardio 最新版中提供的 chrome.driver 所有麻烦都可以解决了，<br>chrome.driver 会自动查找Chrome的安装位置、版本号，自动匹配最合适的ChromeDriver版本，并且负责自动下载安装，自动分配空闲端口，所有事情全自动准备好，只要运行下面的代码就可以了。  </p><p>现在看代码，用法非常简单:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebDriver自动化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chrome.driver;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建chromeDriver对象</span></span><br><span class="line"><span class="comment">//协议文档 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol</span></span><br><span class="line"><span class="keyword">var</span> driver = chrome.driver();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建会话，打开chrome浏览器，Chrome新版会强制显示控制台</span></span><br><span class="line"><span class="keyword">var</span> browser = driver.startBrowser();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开网页</span></span><br><span class="line">browser.go(<span class="string">"http://www.so.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找文本输入框</span></span><br><span class="line"><span class="keyword">var</span> ele = browser.querySelector(<span class="string">"#input"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在网页输入框输入内容</span></span><br><span class="line">ele.setValue( <span class="string">"ChromeDriver"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟点击按钮</span></span><br><span class="line">browser.querySelector(<span class="string">"#search-button"</span>).click();</span><br></pre></td></tr></table></figure><p>下面的问题在新版中已解决，可忽略：</p><blockquote><p>注意 Chrome新版会强制显示控制台（ 隐藏也会强行弹出黑窗口，旧版可以隐藏这个黑窗口 ），</p><p>如果想隐藏黑窗口，那么可以用旧版Chrome，在创建 chrome.driver对象时可以在参数中自定义chrome.exe的路径。</p></blockquote><h2 id="调用-Electron"><a href="#调用-Electron" class="headerlink" title="调用 Electron"></a>调用 Electron</h2><p>也可以通过 ChromeDriver 调用 Electron，几句代码就可以了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> electron.driver;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建chromeDriver对象,协议文档</span></span><br><span class="line"><span class="keyword">var</span> driver = electron.driver();</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换electron默认的开始页</span></span><br><span class="line">driver.addArguments(<span class="string">"--app=http://www.so.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建会话，打开chrome浏览器，Chrome新版会强制显示控制台</span></span><br><span class="line"><span class="keyword">var</span> browser = driver.startBrowser();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开网页</span></span><br><span class="line"><span class="comment">//browser.go("http://www.so.com")</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找文本输入框</span></span><br><span class="line"><span class="keyword">var</span> ele = browser.querySelector(<span class="string">"#input"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在网页输入框输入内容</span></span><br><span class="line">ele.setValue( <span class="string">"ChromeDriver"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟点击按钮</span></span><br><span class="line">browser.querySelector(<span class="string">"#search-button"</span>).click();</span><br></pre></td></tr></table></figure><h2 id="修改-User-Agent"><a href="#修改-User-Agent" class="headerlink" title="修改 User Agent"></a>修改 User Agent</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chrome.driver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> driver = chrome.driver();</span><br><span class="line"></span><br><span class="line">driver.addArguments(<span class="string">"--user-agent=mychrome"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开网页</span></span><br><span class="line">driver.startBrowser().go(<span class="string">"http://www.ip138.com/useragent/"</span>)</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://peter.sh/experiments/chromium-command-line-switches/" target="_blank" rel="noopener">chrome启动参数大全：</a></p></blockquote><h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chrome.driver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> driver = chrome.driver();</span><br><span class="line"></span><br><span class="line">driver.setProxy(</span><br><span class="line">    proxyType = <span class="string">"manual"</span>;</span><br><span class="line">    httpProxy = <span class="string">"127.0.0.1:12043"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>也可以下面这样写:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chrome.driver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> driver = chrome.driver();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> browser = driver.startBrowser(</span><br><span class="line">    proxy =&#123;</span><br><span class="line">        proxyType = <span class="string">"manual"</span>;</span><br><span class="line">        httpProxy = <span class="string">"127.0.0.1:12043"</span></span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="新版功能"><a href="#新版功能" class="headerlink" title="新版功能"></a>新版功能</h2><p>chrome.driver新版功能演示，操作chrome就像直接执行Javascript函数那么简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chrome.driver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> driver = chrome.driver();</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动浏览器</span></span><br><span class="line">browser = driver.startBrowser();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开网页</span></span><br><span class="line">browser.go(<span class="string">"http://www.so.com"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询元素,并且使用元素的querySelector函数查询子元素</span></span><br><span class="line">browser.querySelector(<span class="string">"body"</span>).querySelector(<span class="string">"#input"</span>).setValue( <span class="string">"ChromeDriver"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟点击按钮</span></span><br><span class="line">browser.querySelector(<span class="string">"#search-button"</span>).click()</span><br></pre></td></tr></table></figure><h2 id="隐藏控制台"><a href="#隐藏控制台" class="headerlink" title="隐藏控制台"></a>隐藏控制台</h2><p>网上一些讨论认为这个问题无解，WebDriver也没有找到相关参数，<br>直觉这个可能在启动参数里打开控制台，于是我写了一个假的 chrome.exe，再用 ChromeDriver.exe 调用他，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> win.clip</span><br><span class="line"></span><br><span class="line">win.clip.write(_CMDLINE)</span><br><span class="line"><span class="built_in">console</span>.log(_CMDLINE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.pause();</span><br></pre></td></tr></table></figure><p>chrome.exe获得的启动参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--disable-background-networking --disable-client-side-phishing-detection --disable-default-apps --disable-hang-monitor --disable-popup-blocking --disable-prompt-on-repost --disable-sync --disable-web-resources --enable-automation --enable-logging --force-fieldtrials=SiteIsolationExtensions/Control --ignore-certificate-errors --load-extension=&quot;C:\Users\***\AppData\Local\Temp\***\internal&quot; --log-level=0 --metrics-recording-only --no-first-run --password-store=basic --remote-debugging-port=0 --test-type=webdriver --use-mock-keychain --user-data-dir=&quot;C:\Users\***\AppData\Local\Temp\***&quot; data:,</span><br></pre></td></tr></table></figure><p>我们看到可疑参数<code>--enable-logging</code>，<br>进一步测试发现：排除这个参数就可以关闭新版chrome启动跳出来的控制台窗口了，示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chrome.driver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> driver = chrome.driver( );</span><br><span class="line">driver.setOptions(</span><br><span class="line">    excludeSwitches =&#123;<span class="string">"enable-logging"</span>&#125; <span class="comment">//注意这里参数前千万不要加 --</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">driver.addArguments(<span class="string">"--app=http://www.aardio.com"</span>)</span><br><span class="line"><span class="keyword">var</span> browser = driver.startBrowser();</span><br></pre></td></tr></table></figure><blockquote><p>已更新 chrome.driver 默认禁用控制台窗口，</p><p>但仍然可以使用 <code>driver.addArguments(&quot;--enable-logging&quot;)</code> 启用这个参数。</p></blockquote><h2 id="app、driver-交互"><a href="#app、driver-交互" class="headerlink" title="app、driver 交互"></a>app、driver 交互</h2><p>aardio新版经过大力改进，<br>现在 chrome.app, chrome.driver 已经可以相互结合使用，chrome与aardio交互更加简单方便。<br>下面是一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chrome.app;</span><br><span class="line"><span class="keyword">var</span> app = chrome.app();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chrome.driver;</span><br><span class="line"><span class="keyword">var</span> driver = chrome.driver();</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定允许chrome中使用JS直接调用的函数</span></span><br><span class="line">app.external = &#123;</span><br><span class="line"></span><br><span class="line">    test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       app.msgbox(<span class="string">"页面js调用了aardio函数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正式的启动chrome进程</span></span><br><span class="line">app.start(<span class="string">"http://www.aardio.com"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动浏览器，加载aardio.js，并打开ChromeDriver自动化接口</span></span><br><span class="line">    <span class="keyword">var</span> browser = driver.startAppBrowser(app,args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行JS脚本</span></span><br><span class="line">    browser.doScript(<span class="string">`</span></span><br><span class="line"><span class="string">        document.addEventListener("click", function(event) &#123;</span></span><br><span class="line"><span class="string">            aardio.test();</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    `</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> browser;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">win.loopMessage();</span><br></pre></td></tr></table></figure><h2 id="禁用自动化测试提示"><a href="#禁用自动化测试提示" class="headerlink" title="禁用自动化测试提示"></a>禁用自动化测试提示</h2><p>方法一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chrome.driver;</span><br><span class="line"><span class="keyword">var</span> driver = chrome.driver();</span><br><span class="line">driver.removeArguments(<span class="string">"--enable-automation"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>虽然不显示上面的提示了，但是弹出一个更大的警告。</p></blockquote><p>方法二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chrome.driver;</span><br><span class="line"><span class="keyword">var</span> driver = chrome.driver();</span><br><span class="line">driver.addArguments(<span class="string">"--disable-infobars"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不显示上面的提示，也没有警告了，但是可以看到提示框显示然后快速的关掉，会闪烁一下。</p></blockquote><p>方法三:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> chrome.driver;</span><br><span class="line"><span class="keyword">var</span> driver = chrome.driver();</span><br><span class="line">driver.addArguments(<span class="string">"--app=http://www.so.com/index.html"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>用–app模式的方法完美，地址栏、提示框、警告都去掉了，</p><p>但是有一个奇怪的事情是，启动网址要写成 <a href="http://www.so.com/index.html" target="_blank" rel="noopener">http://www.so.com/index.html</a> 这样，如果不写 index.html 有时候会白屏，但不是每个网站都这样。</p></blockquote><h2 id="清理临时文件"><a href="#清理临时文件" class="headerlink" title="清理临时文件"></a>清理临时文件</h2><p>Chrome每个进程只能绑定单独的用户目录 - 才能创建单独的远程调试端口，<br>ChromeDriver 的办法是每次都创建一个临时的用户目录，然后每次都创建新的临时用户目录，而且又不负责删除（其实可以设置为重启系统自动删除，不知道Chrome为什么没有这么做），所以我们只好自己清理了，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> fsys;</span><br><span class="line">fsys.enum( fsys.getTempDir(), <span class="string">"scoped_dir*_*"</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">dir,filename,fullpath,findData</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!filename)&#123;</span><br><span class="line">            <span class="keyword">if</span>( ..io.exist( io.joinpath(fullpath,<span class="string">"DevToolsActivePort"</span>) ) )&#123;</span><br><span class="line">                fsys.delete(fullpath)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( ..io.exist( io.joinpath(fullpath,<span class="string">"internal.zip"</span>) ) )&#123;</span><br><span class="line">                fsys.delete(fullpath)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.pause(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家知道Chrome每个版本的适用ChromeDriver版本都不一样，&lt;br&gt;安装不同的Chrome就要去下载不同的ChromeDriver.exe，而且还要命令行启动，绑定固定端口一搞不好还会跟别的进程冲突了。&lt;/p&gt;
    
    </summary>
    
      <category term="AArdio" scheme="http://suiang.cn/categories/AArdio/"/>
    
    
      <category term="AArdio" scheme="http://suiang.cn/tags/AArdio/"/>
    
      <category term="Chrome" scheme="http://suiang.cn/tags/Chrome/"/>
    
      <category term="WebDriver" scheme="http://suiang.cn/tags/WebDriver/"/>
    
  </entry>
  
  <entry>
    <title>AArdio 简单服务器示例</title>
    <link href="http://suiang.cn/posts/214/"/>
    <id>http://suiang.cn/posts/214/</id>
    <published>2020-09-10T16:59:13.900Z</published>
    <updated>2020-09-10T16:59:13.900Z</updated>
    
    <content type="html"><![CDATA[<p>使用 aardio 中的 <code>simpleHttpServer</code> 库实现 python 例程中的 HTTP 服务器功能！</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单服务器示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">console</span>;</span><br><span class="line"><span class="keyword">import</span> process;</span><br><span class="line"><span class="keyword">import</span> wsock.tcp.simpleHttpServer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> srvHttp = wsock.tcp.simpleHttpServer()</span><br><span class="line">srvHttp.documentRoot = <span class="string">"d:\"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(srvHttp.getUrl());</span></span><br><span class="line"><span class="string">process.execute(srvHttp.getUrl());</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">srvHttp.run( </span></span><br><span class="line"><span class="string">    function(response,request)&#123; </span></span><br><span class="line"><span class="string">        import fsys;</span></span><br><span class="line"><span class="string">        import inet.url;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        if(!fsys.isDir(request.path) ) &#123;</span></span><br><span class="line"><span class="string">            if( ..io.exist(request.path) )</span></span><br><span class="line"><span class="string">                response.loadcode(request.path)</span></span><br><span class="line"><span class="string">            else &#123;</span></span><br><span class="line"><span class="string">                request.path = fsys.getParentDir(request.path)</span></span><br><span class="line"><span class="string">            &#125; </span></span><br><span class="line"><span class="string">        &#125; </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        response.write("</span> &lt;title&gt;Directory listing <span class="keyword">for</span> /&lt;/title&gt;</span><br><span class="line">&lt;body&gt;&lt;h2&gt;Directory listing for",request.path,"&lt;/h2&gt;&lt;hr&gt;&lt;ul&gt;")</span><br><span class="line"></span><br><span class="line">        var file,dir = fsys.list(request.path,,"*.*");</span><br><span class="line">        for(i=1;#dir;1)&#123;</span><br><span class="line">            response.write('&lt;li&gt;&lt;a href="'</span><br><span class="line">                ,inet.url.append(request.path,dir[ i ])</span><br><span class="line">                ,'"&gt;'+tostring(i)+") ",dir[ i ],'&lt;/a&gt;&lt;br&gt;\r\n');</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(i=1;#file;1)&#123;</span><br><span class="line">            response.write('&lt;li&gt;&lt;a href="'</span><br><span class="line">                ,inet.url.append(request.path,file[ i ])</span><br><span class="line">                ,'"&gt;'+tostring(i)+") ",file[ i ],'&lt;/a&gt;&lt;br&gt;\r\n');</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><a href="http://bbs.aardio.com/forum.php?mod=redirect&amp;goto=findpost&amp;ptid=13737&amp;pid=74460" target="_blank" rel="noopener">用aardio实现python例程中的HTTP服务器功能</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 aardio 中的 &lt;code&gt;simpleHttpServer&lt;/code&gt; 库实现 python 例程中的 HTTP 服务器功能！&lt;/p&gt;
    
    </summary>
    
      <category term="AArdio" scheme="http://suiang.cn/categories/AArdio/"/>
    
    
      <category term="AArdio" scheme="http://suiang.cn/tags/AArdio/"/>
    
  </entry>
  
</feed>
