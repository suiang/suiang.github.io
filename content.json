[{"title":"AArdio 调用Go语言","date":"2020-09-10T16:59:13.915Z","path":"posts/48288/","text":"go语言自带的jsonrpc 不支持http/websocket，而是使用tcp协议，aardio中增加了一个库 wsock.tcp.jsonClient 支持与go语言进行jsonrpc调用。 先使用go语言编写一个exe文件（ 当然你可以把后缀名改为 dll，下面的代码一样可以运行 ）go语言代码如下，注意 go里面{换行写是语法错误 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"fmt\" \"log\" \"net\" \"net/rpc\" \"net/rpc/jsonrpc\")type Args struct &#123; X, Y int&#125;var listener net.Listenertype Calculator struct&#123;&#125;func (t *Calculator) Add(args *Args, reply *int) error &#123; *reply = args.X + args.Y return nil&#125;func (t *Calculator) Exit(args *int, reply *int) error &#123; listener.Close() return nil&#125;func main() &#123; cal := new(Calculator) server := rpc.NewServer() server.Register(cal) listener, e := net.Listen(\"tcp\", \"localhost:0\") if e != nil &#123; fmt.Printf(\"error:%s\\n\", e) return &#125; else &#123; fmt.Printf(\"%s\\n\", listener.Addr().String()) &#125; for &#123; if conn, err := listener.Accept(); err != nil &#123; log.Fatal(\"error: \" + err.Error()) &#125; else &#123; go server.ServeCodec(jsonrpc.NewServerCodec(conn)) &#125; &#125;&#125; 假设上面用go语言生成的exe文件名为gotest.exe，并且是放在当前工程目录下，然后我们用下面的 aardio 代码调用这个 gotest.exe 里的go函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import win.ui;/*DSG&#123;&#123;*/var winform = win.form(text=\"aardio调用go语言演示\";right=759;bottom=469)winform.add(button=&#123;cls=\"button\";text=\"调用Go语言的Calculator.Add函数\";left=382;top=389;right=678;bottom=427;z=5&#125;;edit=&#123;cls=\"edit\";left=19;top=12;right=732;bottom=352;edge=1;hscroll=1;multiline=1;vscroll=1;z=1&#125;;editX=&#123;cls=\"edit\";text=\"2\";left=109;top=392;right=185;bottom=424;edge=1;z=2&#125;;editY=&#123;cls=\"edit\";text=\"3\";left=238;top=392;right=320;bottom=420;edge=1;z=3&#125;;static=&#123;cls=\"static\";text=\"+\";left=198;top=395;right=230;bottom=420;align=\"center\";transparent=1;z=4&#125;)/*&#125;&#125;*/import wsock.tcp.jsonClient;import process.popen;//gotest.exe是使用go语言编写的exe文件。var gofile = process.popen(\"/gotest.exe\");if(!gofile) return winform.msgbox(\"启动go程序失败\");//读取服务端地址(使用自动分配的空闲端口避免冲突)var url = gofile.read();if( !url || string.startWith(url,\"error:\") ) return winform.msgbox(\"启动go程序失败\");//连接go语言服务端var go = wsock.tcp.jsonClient(url)winform.edit.print(\"已连接到go程序\",url);winform.button.oncommand = function(id,event)&#123; //调用go语言提供的函数 var rep = go.Calculator.Add(&#123; X = tonumber(winform.editX.text); Y = tonumber(winform.editY.text); &#125; ) if( rep[[\"result\"]] )&#123; winform.edit.print( \"调用成功\", rep.result ) &#125; else &#123; winform.edit.print( rep[[\"error\"]] ) &#125;&#125;winform.show()win.loopMessage();//通知go程序退出go.Calculator.Exit(0); 附：调用Go语言编译器例子 12345678910111213import console;import golang;var go = golang();go.runCode(\"/hello.go\",`package mainimport \"fmt\"func main() &#123; fmt.Println(\"hello world\")&#125;`)console.pause(); 最新版golang扩展库已支持自动下载配置Go编译器。Go最新版已经支持调用生成DLL文件（需要调用gcc），在aardio中可以直接调用Go生成的DLL文件（使用cdecl调用约定），下面是调用Go编译器生成DLL的演示。 下面看演示： 1234567891011121314151617181920212223242526272829303132333435import console;import golang;//创建Go编译器var go = golang();//Go源码与字符串都是UTF-8编码，跟aardio一样很方便string.save(\"/hello.go\",`package mainimport \"C\"import \"fmt\"//export SayHellofunc SayHello(name string) &#123; fmt.Printf(\"Go says: %s!\\n\", name)&#125;func main() &#123; //DLL入口函数,没有也要写个空的&#125; `)//编译Go源码生成DLL文件go.buildShared(\"/hello.go\",\"/hello.dll\");//加载Go编译的DLL，注意要指定cdecl调用约定var dll = raw.loadDll(\"/hello.dll\",,\"cdecl\");//直接就可以调用DLL里的函数，不用声明console.open();var str = \"必须在Go函数名前面加上 export 函数名的注释才能导出函数\";dll.SayHello(str,#str);console.log( n )console.pause(); Go写DLL要注意一个特别的地方，Go导出函数前必须写一行注释声明导出函数，例如上面的 //export SayHello Go语言里的字符串GoString是一个结构体，用aardio来表示是这样的： 12345678class goString&#123; ctor( str )&#123; this.s = str; this.n = #str; &#125;; string s; addr n;&#125; 如果是在API函数里传值，一个GoString展开为2个API参数来表示就可以了（一个字符串，后面跟一个字符串长度） 因为aardio传结构体都是传指针，如果用结构体，在Go里面要声明为指针，示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243import console;import golang;//创建Go编译器var go = golang();//Go源码与字符串都是UTF-8编码，跟aardio一样很方便string.save(\"/hello.go\",`package mainimport \"C\"import \"fmt\"//export SayHellofunc SayHello(name *string) &#123; fmt.Printf(\"Go says: %s!\\n\", *name)&#125;func main() &#123; //DLL入口函数,没有也要写个空的&#125; `)//编译Go源码生成DLL文件go.buildShared(\"/hello.go\",\"/hello.dll\");//加载Go编译的DLL，注意要指定cdecl调用约定var dll = raw.loadDll(\"/hello.dll\",,\"cdecl\");class goString&#123; ctor( str )&#123; this.s = str; this.n = #str; &#125;; string s; addr n;&#125;//直接就可以调用DLL里的函数，不用声明console.open();dll.SayHello( goString( \"必须在Go函数名前面加上 export 函数名的注释才能导出函数\") );console.log( n )console.pause(); 需要先安装MinGW( GCC ) 可以下载安装 MinGW-W64: https://sourceforge.net/projects/mingw-w64 这个只能安装在64位系统。也可以下载安装 TDM-GCC: http://tdm-gcc.tdragon.net/download 这个提供支持32位、64位安装包。 golang扩展库会自动搜索MinGW,MinGW-W64,TDM-GCC的安装位置，不需要手动配置。当然也可以调用golang扩展库提供的addPath函数自己添加gcc.exe所在的目录。 Go生成的文件很大，加上-ldflags &quot;-s -w&quot;参数会小一些，go.buildShared() 已经自动加上这些参数。编译上面的代码生成的DLL只有1MB多一点，而且可以支持WinXP，不需要依赖外部运行库，还是非常不错的。而且测试了一下，编译的DLL还能内存加载。","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"},{"name":"Golang","slug":"Golang","permalink":"http://suiang.cn/tags/Golang/"}]},{"title":"使用 web.rest 调用 REST API","date":"2020-09-10T16:59:13.914Z","path":"posts/11315/","text":"web.rest下面的支持库最简单的用法就是作为一个 HTTP客户端使用，该客户端对象简化了get,post,put,patch,delete 等常用的 HTTP请求操作，并提供编码请求数据、解码返回数据的功能。 标准库中用于调用 REST API 的库： web.rest.client 请求参数使用urlencode编码,服务器返回文本数据。 web.rest.xmlClient 请求参数使用urlencode编码,服务器返回xml格式数据。 web.rest.jsonLiteClient 请求参数使用urlencode编码,服务器返回JSON格式数据。 web.rest.jsonClient 请求参数与服务器返回数据都使用JSON格式。 除了与服务器交互的数据格式不同以外, 这几个库的接口用法完全一样，可以看看这几个库的源码实际上他们都是调用 web.rest.client 这一个库。 基本的 HTTP 请求web.rest下面的支持库最简单的用法就是作为一个HTTP客户端使用，该客户端对象简化了get,post,put,patch,delete等常用的HTTP请求操作，并提供编码请求数据、解码返回数据的功能，下面是一个最简单的示例： 1234567891011import console;import web.rest.jsonLiteClient;var restClient = web.rest.jsonLiteClient();var jsonData = restClient.post(\"http://httpbin.org/post\", &#123; 用户名 = \"用户名\"; 密码 = \"密码\";&#125;)console.dumpJson(jsonData)console.pause(true); 从上面的示例可以看出，我们上传参数的是aardio中的对象，返回的数据也被自动解码为aardio对象，虽然 HTTP传输使用的是 JSON 数据，但使用时不需要去管 JSON 的编解码等一系列的操作。 转换为 AArdio 函数web.rest 不仅仅可以用来做上面这些简单的 HTTP请求、以及编解码的操作，他还可以将基本符合 REST风格的 Web API转换为aardio中的函数对象，这非常有意思，REST本身不是一个严格的规范、更缺乏WebService那样的WSDL接口描述服务，但是aardio设计了一种简单可行的声明语法，可以非常方便的把混乱的 Web API转换为统一的 aardio函数。 首先我们看一下 REST API的 URL 一般会是这种格式 http://主机/资源目录名/资源目录名/资源名aardio的web.rest库模块中的客户端对象提供一个 api 函数用于声明一个API接口，api 函数的定义如下： var restApi = restClient.api(&quot;接口URL描述&quot;,&quot;默认HTTP请求动词&quot;) 其中接口URL描述可以直接指定一个web api的网址，在该网址中还可以使用变量，变量放在花括号中，例如：http://主机/{变量名}/资源目录名/资源名 aardio并不关心变量名的内容是什么，只关心它们出现的前后顺序，当调用restApi的成员函数时会使用函数名替换接口 URL 中的变量生成新的请求URL。 下面是一个简单的示例：123456789101112131415161718192021import console;import web.rest.jsonClient;// 创建REST客户端var restClient = web.rest.jsonClient();//声明一个API接口,第一个参数指定URL描述var restApi = restClient.api(\"http://httpbin.org/api/&#123;program&#125;/&#123;lang&#125;\")/*下面调用接口函数，在请求时下面代码中的接口名\"language\"替换接口URL描述中的变量&#123;program&#125;接口名\"aardio\"则替换接口URL描述中的变量&#123;lang&#125;最后生成的请求URL为 http://httpbin.org/api/language/aardio */var result = restApi.language.aardio()console.log(\"请求的URL\", restClient.lastRequestUrl)restClient.lastResponse(); //输出服务端最后返回的数据console.pause(); 接口 URL中连接的变量名还可以合并为{...}例如 http://httpbin.org/api/{program}/{lang} 可以简写为 http://httpbin.org/api/{...}当 {...} 出现在尾部时还可以直接省略，例如 http://httpbin.org/api/ 注意head,get,post,put,patch,delete等默认的HTTP请求操作作为函数名时不会被添加到生成的URL中。 这些默认的HTTP方法名在 web.rest.client._defaultMethod 中指定，例如使用 restApi.language.get() 显示的指定 HTTP请求动词为GET。如果不指定 HTTP请求动词，则使用调用 restClient.api(&quot;接口URL描述&quot;,&quot;默认HTTP请求动词&quot;) 函数时第二个参数指定的 HTTP请求动词，不指定该参数时默认为POST。 HTTP规定了九种动词（Verbs）用于指定请求方法：GET,HEAD,POST,DEBUG,PUT,DELETE,PATCH,OPTIONS，而在REST API中用到的有五种 GET，POST，PUT，DELETE，PATCH，他们的用途如下： GET：用于获取数据 POST: 用于创建数据 PUT: 用于替换数据、也可用于更新数据 DELETE: 用于删除数据 PATCH：用于更新数据 上传下载文件如果一个REST API在请求时需要上传、下载文件，那么所有调用规则如前不变。你仅仅需要做的是，在调用API以前指定接受、或发送文件的回调函数以获取上传、下载的进度。 上传文件示例： 12345678restClient.sendFile( \"上传文件路径\" ,function(str,sendSize,contentLength)&#123; ..io.print(\"正在上传\",sendSize,contentLength); &#125;); //在后面再简单的调用API就可以了，例如restApi.upload() 下载文件示例： 12345678restClient.receiveFile( \"上传文件路径\" , function(str,receiveSize,contentLength)&#123; ..io.print(\"正在下载\",receiveSize,contentLength); &#125;); //在后面再简单的调用API就可以了，例如restApi.download() web.rest 也可以支持 multipart/form-data 编码上传文件，示例： 12345678910111213import console; import web.rest.client;var http = web.rest.client(); http.sendMultipartForm( &#123; file = \"@d:\\文件路径\"; username = \"测试\"; &#125;,function(str,sendSize,contentLength)&#123; console.log(\"正在上传\",sendSize,contentLength); &#125; );var str =http.post(\"http://httpbin.org/post\") console.pause(,str) 客户端对象的错误处理web.rest 客户端对象的错误处理与inet.http相同：请求成功返回服务器数据，失败返回空值,错误信息，错误代码等。 注意下面为了演示所有的细节，代码写的比较长，实际开发中不必要写的这么细 12345678910111213141516171819202122232425262728293031323334353637383940414243import console;import web.rest.jsonLiteClient;var restClient = web.rest.jsonLiteClient();/*web.rest客户端对象所以执行HTTP请求的函数遵守以下规则：如果成功:则第一个返回值jsonData为服务端返回数据解码并创建的aardio对象。在HTTP请求遇到错误时:第一个返回值jsonData为空，第二个返回值errMsg为错误信息,返回值errCode为错误代码一般我们可以省略errMsg，errCode这两个返回值不用写，直接判断返回值是否为空即可。 */var jsonData, errMsg, errCode = restClient.post(\"http://httpbin.org/post\", &#123; 用户名 = \"用户名\"; 密码 = \"密码\";&#125;)//jsonData非空为请求成功if (jsonData) &#123; console.dumpJson(jsonData);&#125; else &#123; /* 出错了，如果restClient.lastStatusCode非空则说明服务端返回了HTTP状态代码 */ if (restClient.lastStatusCode) &#123; console.log(restClient.lastStatusMessage()) //查看该状态码的说明 restClient.lastResponse() //输出服务端最后返回的信息 &#125; else &#123; //这通常是没有成功发送请求，在请求到达服务器以前就出错了 console.log(\"HTTP请求遇到错误,WinInet错误代码：\", errCode) console.log( '关于WinInet错误代码的详细说明：\\n http: //support.microsoft.com/kb/193625' ) &#125;&#125;console.pause(); 当然上面的代码一般在调试故障时才需要，一般没必要把错误处理写的这么细，上面的代码也可以简化如下： 123456789101112131415161718import web.rest.jsonLiteClient;var restClient = web.rest.jsonLiteClient();var 鸭子 = restClient.post(\"http://httpbin.org/post\", &#123; 用户名 = \"用户名\"; 密码 = \"密码\";&#125;)if (鸭子[[\"翅膀\"]]) &#123; //这句相当于 if( 鸭子 and 鸭子.翅膀 ) io.print(\"不管服务器给我的是什么鸭子，总之有翅膀的都是好鸭子\")&#125; else &#123; /* 我的网络错误处理模块.错误统一分析( \"怎么回事没翅膀还能叫鸭子吗？\" , restClient.lastStatusCode ) */ return null, \"网络错误\"&#125; 服务端接口设计原则本文参考了 REST API的设计风格、但有部分规则有所变通。在实践中 REST API 完全符合REST规则的比较少见，我在设计 web.rest.client 试图编写一个尽可能通用的支持库、但是发现REST API的实现真是五花八门，而且也缺乏一个统一的接口描述规则。 如果你需要为你的aardio客户端程序设计自己的Web API，那么参考下面的几条原则去实现服务端接口 - 这可以让标准库里 web.rest.client 方便的支持该API( 请参考：使用 web.rest 调用 REST API ). 资源定位路径URL应用于清晰的展现资源定位路径，目录应当使用清晰的资源名称，并可以使用统一的URL接口描述语法声明该API。 例如：http://主机/资源分类/资源目录/资源名/资源ID 原则上不应当把资源名放在URL参数里， 但是要使用这样的友好URL在现实中是用一定代价的，对于一般的Web服务器这可能需URL重写,有一定的性能负担。所以也可以将资源名放到URL参数里，例如 HTTP://主机/资源分类?资源目录=目录名&amp;资源名=资源名&amp;资源ID=资源ID 要注意这里的资源定位有关的参数应当直接放到URL的参数里也就是?号后面，要将资源定位的参数与HTTP提交的参数分开来( 如果你用过 web.rest.client 就知道为什么要这样做 )，并且要按资源定位关系决定参数出现的先后关系。 最后生成的URL要能使用以下的URL描述规则:URL中的资源名应当能使用{模板变量}代替、{模板变量}的先后关系应当对应资源名的出现顺序。{模板变量}包含在花括号里 - 可以使用多个数字或字母，数值的大小并不重要，URL描述仅关心资源出现的先后关系。可以使用 {...} 表示不定个数的模板变量。 http://主机/资源分类/资源目录/资源名/资源ID 使用URL描述语法转换结果就是这样： http://主机/{res}/{category}/{name/{id} 也可以使用 http://主机/{res}/{…} 表示。如果 {...} 出现在最后则可以省略 HTTP://主机/资源分类?资源目录=目录名&amp;资源名=资源名&amp;资源ID=资源ID使用URL描述语法转换以后： HTTP://主机/{res}?资源目录={category}&amp;资源名={name}&amp;资源ID={id} 可以看到资源名是不是写到参数里都能清晰的展现资源定位，要注意 Web API 并不是浏览器，URL并不会出现在浏览器的地址栏，设计一个友好的 API URL 重要的是编程语言里能不能更好的理解并自动分析转换。 例如aardio中的 web.rest.client 就按照这种 URL 描述语法自动的将 URL 描述转换为aardio中的函数对象。 不包含动词原则上URL不应当包含动词，使用HTTP协议的指令动词表示要执行的操作: GET: 表示获取资源POST: 表示新增数据PUT: 表示替换数据DELETE: 表示删除数据PATCH: 表示更新数据 一般的Web服务器因为安全方面的考虑对HEAD、GET、POST之外的请求有所限制, 很多API用POST替代PUT,DELETE的功能，而又要做到URL中不出现动词，就背离了REST的初衷了。 因此建议可选在URL资源定位的最可选性的添加扩展的操作动词，例如：http://host/group/user/userid/ 使用get读取用户信息http://host/group/user/userid/password/change 使用扩展的change方法修改用户密码 如果按这种规则实现服务端的API，那么在aardio里用 web.rest.client 调用起来就很方便，示例： 123456789101112import web.rest.jsonClient;var client = web.rest.jsonClient()var api = client.api(\"http://host/&#123;group&#125;/&#123;..&#125;\")// GET方法读取用户信息var userInfo = api.xgroup.user[userId].get()// 使用扩展的change方法修改密码api.xgroup.user[userId].passord.change( pwd = \"旧密码\"; newPwd = \"新密码\";) 为什么不直接在每一个请求里写具体的URL呢？要考虑到实现一个API的扩展库，API服务端的地址可能发生变更，使用上面的方法就可以简单的维护一个声明URL参数即可。 不出现文件后缀名Web API 的URL中不应出现文件后缀名：例如： http://host/x/y.php 应当在服务器上移动到 http://host/x/y/index.php ，然后提供给客户端的API应隐藏默认的文档名，即 http://host/x/y/ 这样的好处是服务端变更实现会非常方便。 不出现 IP 地址Web API 的URL中不应出现IP地址，即使是测试期间，也应尽可能的使用域名替代IP地址。","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"},{"name":"Web","slug":"Web","permalink":"http://suiang.cn/tags/Web/"}]},{"title":"使用 GitHub 搭建个人博客","date":"2020-09-10T16:59:13.908Z","path":"posts/48270/","text":"Hexo , 一个简单地、轻量地、基于 Node 的一个静态博客框架。下面介绍下如何使用 hexo 和 github pages 搭建个人博客。 准备工作 注意：本文针对Windows平台和Hexo 3.2.2 123456$ hexo -vhexo: 3.2.2hexo-cli: 1.0.2os: Windows_NT 10.0.14393 win32 x64http_parser: 2.7.0node: 6.10.1 安装 Github For Windows主要使用 git bash，如果对 git 命令不熟悉的也可以使用 git 客户端进行某些操作Github For Windows 安装 node.js因为要使用 npm，比较简单的方法就是安装 node.js 安装完成后添加 Path 环境变量，使 npm 命令生效;C:\\Program Files\\nodejs\\node_modules\\npm 创建 Github Pages没有Github 账号的话，需要注册一个，然后创建一个仓库，名字是[yourGithubAccount].github.io 配置 ssh key使用 git bash 生成 public ssh key, 以下是最简单的方法 1$ ssh-keygen -t rsa 然后在 C:\\Users\\[用户名]\\.ssh 目录下会生成 id_rsa.pub ，将内容完全复制到 Github Account Setting 里的 ssh key 粘贴即可。 测试 123$ ssh -T git@github.comHi [yourGithubAccount]! You&apos;ve successfully authenticated,but GitHub does not provide shell access. 设置用户信息 12$ git config --global user.name &quot;[yourName]&quot;//用户名$ git config --global user.email &quot;[yourEmail]&quot;//填写自己的邮箱 经过以上步骤，本机已成功连接到 github，为部署打下基础。 配置 Hexo本地 clone创建本地目录，然后使用 git bash 或者客户端 clone 之前创建的仓库[yourGithubAccount].github.io 安装、配置 Hexo进入仓库目录，使用 npm 安装配置 hexo 123$ npm install -g hexo-cli$ npm install hexo --save$ hexo init 安装 Hexo 插件 12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 安装 ejs， 否则无法解析模板 1$ npm install ejs 安装 hexo 所需的依赖模块1npm install 然后运行下面的命令生成 public 文件夹 12$ hexo g$ hexo s 在浏览器输入 localhost:4000 本地查看效果 主题hexo 有很多主题可选，我选了 indigo，Material Design 风格的Hexo主题，基于 Hexo 3.0+ 制作。支持多说评论、网站统计、分享等功能，只要稍微配置即可使用。可以根据自己需求进行选择。 使用 hexo部署配置 _config.yml 1234deploy: type: git repository: git@github.com:[yourGithubAccount]/[yourGithubAccount].github.io.git branch: master 1$ hexo d 即可将 hexo 部署到 github 上 提示找不到 git 时 需执行（虽然之前已经执行过） 1npm install hexo-deployer-git --save 然后 1$ hexo d 即可访问：1http://[yourGithubAccount].github.io/ 发表新文章1$ hexo new &quot;title&quot; 然后在 source/_post 下会生成该.md文件，即可使用编辑器编写了编写过程中，可以在本地实时查看效果，很是方便。支持 markdown，不了解的自行 百度 。 编写完成后，部署还是一样的 1$ hexo d -g 如果部署过程中报错，可执行以下命令重新部署 123$ hexo clean$ hexo generate$ hexo deploy 添加自定义页面1$ hexo new page &quot;about&quot; 该命令会生成 source/about/index.md，编辑即可 插件的升级与卸载12$ npm update$ npm uninstall &lt;plugin-name&gt; 更新 hexo1npm update -g hexo 绑定自定义域名在 /source/ 目录下新建内容为自定义域名的 CNAME 文件，部署即可（域名设置略） 备注：Hexo简写命令 1234hexo n #newhexo g #generatehexo s #serverhexo d #deploy","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://suiang.cn/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://suiang.cn/tags/Github/"}]},{"title":"不声明直接调用 API 函数","date":"2020-09-10T16:59:13.907Z","path":"posts/35919/","text":"一般建议不要先声明API再去调用，直接调用更方便也更节省资源(除非有特殊的数据类型必须通过声明API来指定)。 示例： ::User32.MessageBox(0,&quot;测试&quot;,&quot;标题&quot;,0) 添加参数的规则 调用约定在加载DLL的参数中指定,支持cdecl不定个数参数,有很多API根据不同的用法可以传入不同类型的参数， 如果我们在aardio中不是先写一个API声明，而是直接去调用API，这时候就可以根据需要更灵活的改变参数类型。一般建议不要先声明API再去调用 - 直接调用更方便也更节省资源(除非有特殊的数据类型必须通过声明API来指定)。 null参数不可省略 数值参数一律处理为32位int整型，32位整数类型，小于32位的整数、枚举类型、8位或32位bool值都跟int 32位数值兼容，可以直接写在参数里,示例： 32位整型以及小于32位的整型参数都可以直接传入aardio数值。例如C语言API声明为：void setNumber( short n )在aardio里如下调用就可以 dll.setNumber( 123 ) 64位整数（C语言中的long long)可以math.size64对象表示，或者用两个数值参数表示一个64位整数值参数，其中第一个参数表示低32位数值,第二个参数表示高32位数值（一般可以直接写0）。 对于任何数值类型的指针（输出参数）一律使用结构体表示，例如C语言API声明为：void getNumber( short *n ) 在aardio里如下调用就可以 12var n = &#123; word value &#125;dll.getNumber(n) API函数中的数组指针，在aardio中可以使用结构体指针替代，例如C语言中的 int data[4]; 在aardio中写为 {int data[4];} 如果是字节数组指针也可以使用raw.buffer()函数创建的字节数组替代。 所有结构体一律处理为输出参数并在aardio返回值中返回，其他类型只能作为输入参数。注意在aardio中，任何结构体在API调用中传递的都是结构体指针（传址）。 因为没有参数类型声明，调用代码有责任事先检查并保证参数类型正确，传入错误的参数可能导致程序异常。 获取返回值的规则 直接调用API的 返回值默认为int类型 可以使用[API尾标]改变返回值为其他类型 未声明的 API函数自身在aardio中是一个普通的aardio函数对象，不能作为函数指针参数传给 API参数（声明后的API函数对象是可以的） 使用 [ API 尾标 ]当不声明直接调用API时，API函数名尾部如果不是大写字符，则可以使用一个大写的特定字符（API尾标）修改默认的API调用规则，在API函数名后添加尾标，不会影响到查找API函数的结果，无论真实的API带不带指定的尾标 - aardio都能找到真实的函数。 所有可用的[API尾标]如下（函数名的最后一个特定字符是尾标）： dll.ApiNameW() 切换到Unicode版本，字符串UTF8UTF16双向转换dll.ApiNameA() 切换到ANSI版本,字符串不作任何转换dll.ApiNameL() 返回值为64位LONG类型dll.ApiNameP() 返回值为指针类型dll.ApiNameD() 返回值为double浮点数dll.ApiNameF() 返回值为float浮点数dll.ApiNameB() 返回值为 C++ 中的8位bool类型 如何使用字符串 字符串一般直接转换为字符串指针，buffer类型字节数组也可以作为字符串指针使用，如果API需要向字符串指向的内存中写入数据，那么必须使用raw.buffer()函数创建定长的字节数组。普通的aardio字符串指向的内存是禁止写入的（aardio中修改普通字符串会返回新的字符串对象，而不是在原内存上修改数据） 对于非Unicode API字符串直接输入原始的数据（对于文本就是UTF8编码），对于声明为Unicode版本的API，字符串会被强制转换为Unicode(UTF16)，但buffer类型的参数仍然会以二进制方式使用原始数据与API交互（不会做文本编码转换） 可以在 raw.loadDll() 加载 DLL时在调用约定中添加,unicode声明一个 DLL默认使用Unicode API。 也可以在函数名后添加尾标 W 声明一个Unicode API, 即使真实的API函数名后面并没有 W 尾标，你仍然可以添加 W 尾标调用 API。aardio在找不到该 API函数时，会移除 W 尾标，并且认为该 API函数是一个Unicode API，注意 W 必须大写并紧跟在小写字母后面。 直接调用 API时，如果目标 API函数并不存在，而是存在加 W 尾标的Unicode API,aardio将会自动切换到Unicode API，并在调用函数时，自动将aardio的UTF8编码转换为 API所需要的UTF16编码。 反之，在API函数名后也可以显式的添加 A 尾标强制声明此 API是一个 ANSI 版本的函数（对字符串参数不使用任何 Unicode 转换，即使加载 DLL时在调用约定中声明了默认以 unicode 方式调用），规则同上 - 也即真实的API函数名后面有没有 A 尾标并不重要，在aardio中都可以加上 A 尾标。 一些API在接收字符串、字节数组等参数时，通常下一个参数需要指定内存长度， aardio中用#操作符取字符串、缓冲区的长度时，返回的都是字节长度，一些 API可能需要你传入字符个数， 发果是Unicode版本的 API一个字符为两个字节，对于一个UTF8字符串应当事用string.len()函数得到真正的字符长度, 而Unicode字符串则用#取到字节长度后乘以2即可。","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"},{"name":"API","slug":"API","permalink":"http://suiang.cn/tags/API/"}]},{"title":"Hello World！","date":"2020-09-10T16:59:13.904Z","path":"posts/16107/","text":"欢迎使用 Hexo ! 这是你的第一篇文章。检查 文档 以获取更多信息。如果你在使用Hexo时遇到任何问题，你可以在 故障排除 中找到答案，或者你可以在 GitHub 提问。 快速开始创建新帖子1$ hexo new \"My New Post\" 更多信息: Writing 运行服务器1$ hexo server 更多信息: Server 生成静态文件1$ hexo generate 更多信息: Generating 部署到远程站点1$ hexo deploy 更多信息: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://suiang.cn/tags/Hexo/"}]},{"title":"WebDriver 协议客户端","date":"2020-09-10T16:59:13.903Z","path":"posts/39047/","text":"WebDriver 是用于控制浏览器的一个协议，我们试试用 aardio 来实现这个功能，我们只需要浏览器提供的接口。 例如 chromeDriver.exe （ 不同版本的chrome要下载不同版本的 chromeDriver.exe ）。其他的东西我们就不需要了，安装这个安装那个多麻烦对吗？！ 看一下其他语言的封装库，代码可能很多，但是不要被吓倒了，用 aardio 我们真的只要几句代码就可以实现 WebDriver 客户端了。 12345678910111213141516171819202122232425262728293031import web.rest.jsonClient;//协议文档 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocolvar http = web.rest.jsonClient();var webDriver = http.api(\"http://localhost:9515/\");//改成chromedriver的实际端口//创建会话，打开chrome浏览器var chrome = webDriver.session( desiredCapabilities = &#123; browserName = \"chrome\" &#125;);//获取打开的浏览器会话var session = webDriver.session[chrome.sessionId];//打开网页session.url( url = \"http://www.baidu.com\")//查找百度输入框var ele = session.element( using = \"id\"; value = \"kw\";)//在网页输入框输入内容session.element[ ele.value.ELEMENT ].value( value = &#123; \"ChromeDriver\" &#125;;)","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"},{"name":"Chrome","slug":"Chrome","permalink":"http://suiang.cn/tags/Chrome/"},{"name":"WebDriver","slug":"WebDriver","permalink":"http://suiang.cn/tags/WebDriver/"}]},{"title":"Chrome 系列范例","date":"2020-09-10T16:59:13.901Z","path":"posts/57740/","text":"大家知道Chrome每个版本的适用ChromeDriver版本都不一样，安装不同的Chrome就要去下载不同的ChromeDriver.exe，而且还要命令行启动，绑定固定端口一搞不好还会跟别的进程冲突了。 现在用aardio 最新版中提供的 chrome.driver 所有麻烦都可以解决了，chrome.driver 会自动查找Chrome的安装位置、版本号，自动匹配最合适的ChromeDriver版本，并且负责自动下载安装，自动分配空闲端口，所有事情全自动准备好，只要运行下面的代码就可以了。 现在看代码，用法非常简单: 12345678910111213141516171819202122//WebDriver自动化import chrome.driver;//创建chromeDriver对象//协议文档 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocolvar driver = chrome.driver();//创建会话，打开chrome浏览器，Chrome新版会强制显示控制台var browser = driver.startBrowser();//打开网页browser.go(\"http://www.so.com\")//查找文本输入框var ele = browser.querySelector(\"#input\");//在网页输入框输入内容ele.setValue( \"ChromeDriver\" )//模拟点击按钮browser.querySelector(\"#search-button\").click(); 下面的问题在新版中已解决，可忽略： 注意 Chrome新版会强制显示控制台（ 隐藏也会强行弹出黑窗口，旧版可以隐藏这个黑窗口 ）， 如果想隐藏黑窗口，那么可以用旧版Chrome，在创建 chrome.driver对象时可以在参数中自定义chrome.exe的路径。 调用 Electron也可以通过 ChromeDriver 调用 Electron，几句代码就可以了： 12345678910111213141516171819202122import electron.driver;//创建chromeDriver对象,协议文档var driver = electron.driver();//替换electron默认的开始页driver.addArguments(\"--app=http://www.so.com\");//创建会话，打开chrome浏览器，Chrome新版会强制显示控制台var browser = driver.startBrowser();//打开网页//browser.go(\"http://www.so.com\")//查找文本输入框var ele = browser.querySelector(\"#input\");//在网页输入框输入内容ele.setValue( \"ChromeDriver\" )//模拟点击按钮browser.querySelector(\"#search-button\").click(); 修改 User Agent12345678import chrome.driver;var driver = chrome.driver();driver.addArguments(\"--user-agent=mychrome\")//打开网页driver.startBrowser().go(\"http://www.ip138.com/useragent/\") chrome启动参数大全： 设置代理12345678import chrome.driver;var driver = chrome.driver();driver.setProxy( proxyType = \"manual\"; httpProxy = \"127.0.0.1:12043\") 也可以下面这样写: 12345678910import chrome.driver;var driver = chrome.driver();var browser = driver.startBrowser( proxy =&#123; proxyType = \"manual\"; httpProxy = \"127.0.0.1:12043\" &#125;); 新版功能chrome.driver新版功能演示，操作chrome就像直接执行Javascript函数那么简单 123456789101112131415import chrome.driver;var driver = chrome.driver();//启动浏览器browser = driver.startBrowser();//打开网页browser.go(\"http://www.so.com\")//查询元素,并且使用元素的querySelector函数查询子元素browser.querySelector(\"body\").querySelector(\"#input\").setValue( \"ChromeDriver\" )//模拟点击按钮browser.querySelector(\"#search-button\").click() 隐藏控制台网上一些讨论认为这个问题无解，WebDriver也没有找到相关参数，直觉这个可能在启动参数里打开控制台，于是我写了一个假的 chrome.exe，再用 ChromeDriver.exe 调用他，代码如下： 1234567import console;import win.clipwin.clip.write(_CMDLINE)console.log(_CMDLINE);console.pause(); chrome.exe获得的启动参数如下： 1--disable-background-networking --disable-client-side-phishing-detection --disable-default-apps --disable-hang-monitor --disable-popup-blocking --disable-prompt-on-repost --disable-sync --disable-web-resources --enable-automation --enable-logging --force-fieldtrials=SiteIsolationExtensions/Control --ignore-certificate-errors --load-extension=&quot;C:\\Users\\***\\AppData\\Local\\Temp\\***\\internal&quot; --log-level=0 --metrics-recording-only --no-first-run --password-store=basic --remote-debugging-port=0 --test-type=webdriver --use-mock-keychain --user-data-dir=&quot;C:\\Users\\***\\AppData\\Local\\Temp\\***&quot; data:, 我们看到可疑参数--enable-logging，进一步测试发现：排除这个参数就可以关闭新版chrome启动跳出来的控制台窗口了，示例代码： 123456789import chrome.driver;var driver = chrome.driver( );driver.setOptions( excludeSwitches =&#123;\"enable-logging\"&#125; //注意这里参数前千万不要加 --)driver.addArguments(\"--app=http://www.aardio.com\")var browser = driver.startBrowser(); 已更新 chrome.driver 默认禁用控制台窗口， 但仍然可以使用 driver.addArguments(&quot;--enable-logging&quot;) 启用这个参数。 app、driver 交互aardio新版经过大力改进，现在 chrome.app, chrome.driver 已经可以相互结合使用，chrome与aardio交互更加简单方便。下面是一个简单的例子： 12345678910111213141516171819202122232425262728293031import chrome.app;var app = chrome.app();import chrome.driver;var driver = chrome.driver();//指定允许chrome中使用JS直接调用的函数app.external = &#123; test = function()&#123; app.msgbox(\"页面js调用了aardio函数\"); &#125;&#125;//正式的启动chrome进程app.start(\"http://www.aardio.com\",function(args)&#123; //启动浏览器，加载aardio.js，并打开ChromeDriver自动化接口 var browser = driver.startAppBrowser(app,args); //执行JS脚本 browser.doScript(` document.addEventListener(\"click\", function(event) &#123; aardio.test(); &#125;); `) return browser;&#125;);win.loopMessage(); 禁用自动化测试提示方法一： 123import chrome.driver;var driver = chrome.driver();driver.removeArguments(\"--enable-automation\") 虽然不显示上面的提示了，但是弹出一个更大的警告。 方法二： 123import chrome.driver;var driver = chrome.driver();driver.addArguments(\"--disable-infobars\"); 不显示上面的提示，也没有警告了，但是可以看到提示框显示然后快速的关掉，会闪烁一下。 方法三: 123import chrome.driver;var driver = chrome.driver();driver.addArguments(\"--app=http://www.so.com/index.html\"); 用–app模式的方法完美，地址栏、提示框、警告都去掉了， 但是有一个奇怪的事情是，启动网址要写成 http://www.so.com/index.html 这样，如果不写 index.html 有时候会白屏，但不是每个网站都这样。 清理临时文件Chrome每个进程只能绑定单独的用户目录 - 才能创建单独的远程调试端口，ChromeDriver 的办法是每次都创建一个临时的用户目录，然后每次都创建新的临时用户目录，而且又不负责删除（其实可以设置为重启系统自动删除，不知道Chrome为什么没有这么做），所以我们只好自己清理了，代码如下： 12345678910111213141516import console;import fsys;fsys.enum( fsys.getTempDir(), \"scoped_dir*_*\", function(dir,filename,fullpath,findData)&#123; if(!filename)&#123; if( ..io.exist( io.joinpath(fullpath,\"DevToolsActivePort\") ) )&#123; fsys.delete(fullpath) &#125; if( ..io.exist( io.joinpath(fullpath,\"internal.zip\") ) )&#123; fsys.delete(fullpath) &#125; &#125; &#125;,false);console.pause(true);","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"},{"name":"Chrome","slug":"Chrome","permalink":"http://suiang.cn/tags/Chrome/"},{"name":"WebDriver","slug":"WebDriver","permalink":"http://suiang.cn/tags/WebDriver/"}]},{"title":"AArdio 简单服务器示例","date":"2020-09-10T16:59:13.900Z","path":"posts/214/","text":"使用 aardio 中的 simpleHttpServer 库实现 python 例程中的 HTTP 服务器功能！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344//简单服务器示例import console;import process;import wsock.tcp.simpleHttpServer;var srvHttp = wsock.tcp.simpleHttpServer()srvHttp.documentRoot = \"d:\\\"console.log(srvHttp.getUrl());process.execute(srvHttp.getUrl());srvHttp.run( function(response,request)&#123; import fsys; import inet.url; if(!fsys.isDir(request.path) ) &#123; if( ..io.exist(request.path) ) response.loadcode(request.path) else &#123; request.path = fsys.getParentDir(request.path) &#125; &#125; response.write(\" &lt;title&gt;Directory listing for /&lt;/title&gt;&lt;body&gt;&lt;h2&gt;Directory listing for\",request.path,\"&lt;/h2&gt;&lt;hr&gt;&lt;ul&gt;\") var file,dir = fsys.list(request.path,,\"*.*\"); for(i=1;#dir;1)&#123; response.write('&lt;li&gt;&lt;a href=\"' ,inet.url.append(request.path,dir[ i ]) ,'\"&gt;'+tostring(i)+\") \",dir[ i ],'&lt;/a&gt;&lt;br&gt;\\r\\n'); &#125; for(i=1;#file;1)&#123; response.write('&lt;li&gt;&lt;a href=\"' ,inet.url.append(request.path,file[ i ]) ,'\"&gt;'+tostring(i)+\") \",file[ i ],'&lt;/a&gt;&lt;br&gt;\\r\\n'); &#125; &#125;) 用aardio实现python例程中的HTTP服务器功能","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"}]}]