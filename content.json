[{"title":"CSS 灵活的流(Flow)布局","date":"2020-09-12T06:49:54.447Z","path":"posts/32886/","text":"摘要本部分用于说明流式(flow)属性和弹性(flex)单位. 使用它们可以创建非常灵活地适用于各种各样的视图(view)和内容尺寸(content sizes)的布局。 流式(flow)属性和弹性(flex)单位旨在解决目前现下的 CSS 无法解决或实现的一些问题: 支持在容器(containers)和视口(viewport)中的元素的垂直和水平对齐； 支持当替代元素在同一行内且高度相同时，实现灵活的多栏布局（边栏-内容-边栏）。 支持定义复杂的位置：当元素的视图顺序(visual order)与DOM中的元素顺序不同时，可以使用静态布局。 1. 概述弹性布局(Flexible layouts)是指使用弹性(flex)长度单位和流(flow)属性。 弹性长度单位(flex units)允许使用在定义元素的尺寸(size)、外边距(margin)、 内边距(padding)，作为包含块(containing block)的剩余可用空间的一部分。弹性单位的值是一个十进制数字，数字后加上”*”(星号)作为单位识别符。 流(flow)属性用来定义包含块(contained blocks)在正常流(position:static)中的布局方法。或者可以说，流(flow) 定义了容器的布局管理器。此模块包含以下标准的布局管理器定义： 垂直布局 (vertical) 水平布局 (horizontal) 水平布局-允许换行 (horizontal-flow) 垂直布局-允许换行 (vertical-flow) 模板化布局(templated layout) 弹性(Flex)单元的值可以认为是有弹簧张力的。它根据自己本身的”弹性”来自动调整尺寸和位置。如定义值如下： 上面图片中块的布局的HTML代码如下： 123&lt;div class=\"container\"&gt; &lt;p&gt;... some text ...&lt;/p&gt;&lt;/body&gt; p元素有以下样式： 1234567p&#123; width: 40%; /* 固定宽度 - 容器的40% */ margin-left: 2*; /* 左边的 \"弹簧\" 的力量为 2 */ margin-right: 1*; /* 右边的 \"弹簧\" 的力量为 1 */ border:1px solid black; /* 固定宽度的边框 */&#125; 2. 弹性（Flex）长度单位在弹性单位中，元素的尺寸是对剩余空间内的可用包含框的计算。 弹性单位值是在所有非弹性单位值计算完成后计算的——是布局算法的最后一步。在这一步中，它的值可能来于包含容器的剩余未分配空间。在容器的垂直和水平方向上，所有弹性值在这个剩余未分配空间通过竞争来得出自己的计算值。 弹性单位只适用于元素的CSS属性中的内边距(padding)、外边距(margin)、宽度(width)、高度(height)。 它也可以用在静态(static正常流)、绝对定位(absolute)的元素中。浮动元素(float)不支持弹性单位——若为浮动元素指定了弹性单位值时会被当做auto值。 在计算元素的最终尺寸时，弹性单元的值被解释为一个权重(weight)。如果剩余空间的弹性值总和小于1，相应的剩余部分将保持未分配。若果弹性值总和大于或等于1，所有的剩余空间将使用该弹性值作为比例分配权重来分配。 例如，下面这个示例: 123456#container &#123; width:300px; &#125;#element &#123; width:1*; margin-left:2*; margin-right:1*; border:2px solid; padding:0; &#125; #container元素中的#element元素将会应用下面的这个计算尺寸： 12345弹性值总和 = 1* + 2* + 1* = 4*;待分配宽度 = 300px - 2px - 2px = 296px; // 容器宽度 - 固定边框宽度宽度(width) = 1/4 * 待分配宽度(296px) = 74px;右外边距 = 1/4 * 待分配宽度(296px) = 74px;左外边距 = 2/4 * 待分配宽度(296px) = 148px; 弹性单位值的计算遵循所有的通常约束。 例如, 最小宽度(min-width)和最大宽度(max-width)定义可以”弹性”的宽度的边界。出于弹性单位计算的原因，初始（默认）的最小宽度属性值被解释为具有最小的内在价值(intrinsic value)。 2.1. 最小内在价值(min-intrinsic), 最大内在价值(max-intrinsic) 长度值。CSS 的最小宽度(min-width)、最大宽度(max-width)、宽度(width)和最小高度(min-height)、最大高度(max-height)、高度(height)属性值可以接受以下的指定值： 最小内在价值(min-intrinsic)&#39;和最大内在价值(max-intrinsic)’。 最小内在价值(min-intrinsic) —— 在一些容器中，该值指在相应方向上无需溢出(overflow)渲染时的最小长度。例如：对于设置overflow:auto的元素，它的最小长度为显示时没有滚动条的最小长度。 最大内在价值(max-intrinsic)—— 在一些容器中，该值指所有的子元素显示无需换行时的最小长度。或者说，当某元素的高度为max-intrinsic时，在水平布局(类似*rtl*/*ltr*)的系统,或者垂直布局的系统(类似*ttb*)上，最大内在价值(max-intrinsic)指当该元素的宽度达到最小时的该元素最小高度。 若为段落&lt;p&gt;first second&lt;/p&gt;设置width:min-intrinsic时，该段落的宽度为该段落中最宽的那个单词的宽度。若为这个段落设置width:max-intrinsic时，则它的宽度为该段落中所有单词和空格长度的总和——该段落将呈现为单行文本。 3. 流(flow)属性流(flow)属性定义了容器如何布局它的子元素们。或者说，它建立了容器元素的布局管理器。‘flow’ 该属性定义了子元素在正常流中的布局方法： 文档中使用的术语： 流式容器(flow container) 流式容器(flow container)是指包含&#39;flow&#39;样式属性且值不为default的块元素。这种元素使用给定的布局管理器来布局它的块子元素。如果流式容器(flow container)包含display不为block、list-item、code&gt;table 的子元素，则这些子元素会包装在一个匿名块或表容器以便参与流式布局。 流元素(flowed element) 流元素(flowed element)的直接父元素为流式容器(flow container)。这些元素被父流式容器的布局管理器用来替换。 3.1. 垂直布局(flow:vertical)垂直流比较接近标准的自上而下的块元素的布局方式，例如div, ul等等。和标准布局方式唯一的区别在于硫元素使用弹性单位时。 flow:vertical容器中的所有静态子元素将会被替换为从上到下、一个接一个的根据容器宽度形成一个单一的列。其所包含的定义了弹性单位的子元素的宽度值将会使用容器的宽度值来计算。同样，被包含元素的垂直尺寸会使用容器的高度来计算。如果容器的高度未定义，或者高度定义为height:auto，则将没有剩余空间来分配给弹性值，这样的话，在这个方向上的弹性值可以被忽略掉。 如果容器定义了高度，且它的高度大于被包含元素的最小价值高度(min-intrinsic)，则存在剩余空间。在这样的容器里，这个空间被分配给定义了垂直弹性值的子元素。 例如，下面的样式: 12#container &#123; height:100%; border:1px dotted; &#125;#first &#123; margin-bottom:1*; &#125; 当定义下面的HTML标记时: 12345678910&lt;div id=\"container\"&gt; &lt;h2&gt;Alignment to top/bottom&lt;/h2&gt; &lt;div id=\"first\" style=\"margin-bottom:1*\"&gt; &lt;code&gt;margin-bottom:1*;&lt;/code&gt; &lt;p&gt;Shifts rest to the bottom&lt;/p&gt; &lt;/div&gt; &lt;div id=\"second\"&gt; Normal div &lt;/div&gt;&lt;/div&gt; 则会将#first元素放在#container的顶部，而将#second元素放在它的底部。 3.1.1. 在flow:vertical容器中外边距堆叠(collapsing)在CSS中，被包含元素的垂直编辑通常会叠到一起。 这里唯一需要注意的时当堆叠到垂直边距包含弹性值，而对应的另一个元素是固定值时。这种情况下，这个固定值会作为两个元素间弹性计算值的”最小约束(min-constraint)“。这样，边距是弹性的，但是它不能小于这个固定值。 3.2. 水平布局(flow:horizontal)这是一个单行布局。 设置flow:horizontal的容器的所有静态子元素会水平地一个接一个的排列成一行。布局是相对于容器的方向direction属性进行。 在水平方向上，若子元素的宽度(width)、左右外边距(margin)、边框(border)、内边距(padding)给定了一个弹性值，它们将参与剩余空间的分配。flow:horizontal容器的所有直接子元素将对容器内容区(content box)中左右边界间的剩余空间进行计算，使这个空间根据它们的弹性值进行分配。 在垂直方向上：被包含元素的高度、上下外边距、边框、内边距的弹性值使用容器的高度值来计算。这使flow:horizontal容器的子元素排序不仅是水平地，也可以是垂直的。 下面的样式中，所有的子元素拥有相同的高度： 12#container &#123; flow:horizontal; border-spacing:4px; padding:4px; &#125;#container &gt; div &#123; margin:0; height:1*; &#125; 渲染结果如下: 下面，所有的子元素都设置为最小内在价值高度。而将上外边距设置为1*： 123#container &#123; flow:horizontal; border-spacing:4px; padding:4px; &#125;#container &gt; div &#123; margin-top:1*; height:auto; &#125; /* height:auto意思是&amp;quot\u000fﾅ(￷&lt;&amp;quot高度 */ 3.2.1. flow:horizontal容器中的外边距堆叠flow:horizontal容器中包含块的水平外边距堆叠处理方式和flow:vertical容器相同。而对于in-flow子元素，它们不与flow:horizontal容器的外边距堆叠。 3.2.2. 内在尺寸(Intrinsic dimensions)flow:horizontal容器的内在高度(Intrinsic height)是在它内部的一行中最高的元素的外边距框高度。 flow:horizontal容器的内在宽度是所有子元素在水平边距堆叠的情况下的最小内在宽度之和。 3.3. 水平可换行布局(flow:horizontal-flow)flow:horizontal-flow布局是flow:horizontal布局的一种变种。该布局允许容器的子元素在水平方向上没有足够空间时换行。 clear:left|right|both属性可以明确的中断元素布局流，使其成为多行。 在满足以下基本条件之一时，允许换行： 某元素上使用了clear:left|right|both属性； 该行没有足够的水平工具来放置该元素。 在垂直方向上，设置弹性值的包含块的高度、上下外边距、边框、内边距的值是使用当前行的高度。该行的高度等于在不影响弹性值计算的情况下该行中最高元素的高度。 在水平方向上，一行中的元素的弹性值计算和flow:horizontal布局相同。 例如, 下面的HTML标记语言: 1234567891011121314151617&lt;div style=\"flow:horizontal-flow\" &gt; &lt;div style=\"width:100px\" &gt; width:100px &lt;/div&gt; &lt;div style=\"width:1*\" &gt; flexible width:1* flexible width:1* &lt;/div&gt; &lt;div style=\"width:1*\"&gt; flexible width:1* flexible width:1* flexible width:1* &lt;/div&gt; &lt;div style=\"width:150px\" &gt; width:150px &lt;/div&gt;&lt;/div&gt; 渲染结果如下: 3.4. 垂直可换列布局(flow:vertical-flow)flow:vertical-flow布局类是一个多列布局，似于flow:horizontal-flow。在垂直方向上，元素会从上到下的排列放置。如果容器没有足够的垂直空间，元素会换列，变成多列布局。 clear:left|right|both 属性允许中断列，使其明确地成为多列布局。 在满足一下条件之一时，会进行换列： 在垂直方向上，该列上所有元素的弹性值之和大于1*； clear:left|right|both属性在某个元素中明确使用； 没有足够的垂直空间来放置下一个元素。 在水平方向上，容器内的子元素的宽度、左右外边距、内边距的弹性值使用当前列的宽度来计算。该行的宽度等于在不影响弹性值计算的情况下该行中最宽元素的宽度。 在垂直方向上，某列中元素的弹性值计算方法与flow:vertical布局相同。 例如，下面的HTML标记： 1234567891011121314151617181920212223242526&lt;ul style=\"flow:vertical-flow\"&gt; &lt;li style=\"height:150px\" &gt; 1. height:150px &lt;/li&gt; &lt;li style=\"height:100px\" &gt; 2. height:100px &lt;/li&gt; &lt;li style=\"height:0.3*\" &gt; 3. flexible height:0.3* flexible height:0.3* &lt;/li&gt; &lt;li style=\"height:0.7*\" &gt; 4. flexible height:0.7* flexible height:0.7* flexible height:0.7* &lt;/li&gt; &lt;li style=\"height:150px\" &gt; 5. height:150px &lt;/li&gt; &lt;li style=\"height:150px\" &gt; 6. height:150px &lt;/li&gt; &lt;li style=\"height:150px\" &gt; 7. height:150px &lt;/li&gt;&lt;/ul&gt; 每个列表项设置了width:150px，这会生成下面的布局，列表项会处理成3列： 3.5. 模板布局(flow:”template” / flow: grid(…)) 请注意，该布局是http://www.w3.org/TR/css3-layout/. 的一个简化版本，该想法的所有版权属于该文档的作者。 flow: &lt;模板表达式&gt; 允许根据模板表达式来替换放置元素。 在这里，模板表达式是一个字符串标识序列。每个字符串标识是一个使用空格分隔的名称标识列表中的一项，其中每个标识指定一个网格中的单元格。多列允许有相同的名称。在这种情况下，该标识相当于定义了一个横跨多个单元网格的占位符。 例如, 下面的模板定义了从”a”到”f”的一个3x4的共6个占位网格的表格。某些占位网格跨越了多个单元格： 1234flow: \"a a a\" \"b c e\" \"d c e\" \"d c f\"; 容器中的每个子元素使用 float:&quot;占位标识名称&quot; 属性绑定到模板定义的特定的占位网格对应的位置： 123456789101112131415li:nth-child(1) &#123; float:\"a\"; &#125;li:nth-child(2) &#123; float:\"b\"; width:150px; height:max-intrinsic; &#125;li:nth-child(3) &#123; float:\"c\"; width:*; height:*; &#125; /* flexes, a.k.a. shrink-to-fit */li:nth-child(4) &#123; float:\"d\"; width:150px; height:*; &#125;li:nth-child(5) &#123; float:\"e\"; width:150px; height:*; &#125;li:nth-child(6) &#123; float:\"f\"; width:150px; height:150px; &#125; 注意，在使用该流式(flow)布局的容器内的直接子元素使用float:left|right将不起作用。或者说，被流式布局的元素只能使用flow:&quot;template&quot;定义的单元格来布局。 模板容器中的所有没有绑定到网格的子元素将会作为单独的一行追加到最后。如果有多个子元素有相同的占位符名称，只有第一个(DOM中的顺序)将被绑定到占位网格上，剩余的元素会变成未绑定的。 每个占位符名称在模板中必须是唯一的、矩形的。否则，该模板将无效，流式布局将采用默认的flow:default. 例如，下面的HTML标记： 12345678&lt;ul&gt; &lt;li&gt; \"a\", width:auto (that is 1*), height:auto(that is max-intrinsic) &lt;/li&gt; &lt;li&gt; \"b\", width:150px, height:max-intrinsic &lt;/li&gt; &lt;li&gt; \"c\", width:*, height:* (a.k.a. shrink-to-fit) &lt;/li&gt; &lt;li&gt; \"d\", width:150px, height:* &lt;/li&gt; &lt;li&gt; \"e\", width:150px, height:* &lt;/li&gt; &lt;li&gt; \"f\", width:150, height:150px&lt;/li&gt; &lt;/ul&gt; 设置样式后渲染结果如下： 除了用字符定义名称外，还可以使用子元素在模板容器中的顺序数字，所以下面的这个模板： 123flow: grid(1 1, 2 3); 会导致容器的前三个子元素布局到两行，且第一个元素放置在第一行，而第二、第三个元素放置在第二行。 3.6. row函数布局( flow: row(tag1, tag2, …) )flow:row()函数用来实现类似table的布局。row()函数的参数为元素标签的列表，该列表定义的元素将会放置在表格中的单独一行。 考虑下面的HTML标记: 123&lt;dl&gt;&lt;dt&gt;第一项&lt;/dt&gt; &lt;dd&gt;第一项的描述&lt;/dd&gt; &lt;dt&gt;第二项&lt;/dt&gt; &lt;dd&gt;第二项的描述&lt;/dd&gt;&lt;/dl&gt; 并且设置它的样式如下: 1dl &#123; flow: row(dt,dd); &#125; 则它们将会渲染成如下： 第一项 第一项的描述 第二项 第二项的描述 如果flow:row(...)布局的元素内存在不匹配row中的模板的元素，则该元素将会被放置在单独的一行并跨越所有列。所有考虑下面的HTML标记： 12345678&lt;dl&gt; &lt;header&gt;组别1&lt;/header&gt; &lt;dt&gt;第一项&lt;/dt&gt; &lt;dd&gt;第一项的描述&lt;/dd&gt; &lt;dt&gt;第二项&lt;/dt&gt; &lt;dd&gt;第二项的描述&lt;/dd&gt; &lt;header&gt;组别2&lt;/header&gt; &lt;dt&gt;第三项&lt;/dt&gt; &lt;dd&gt;第三项的描述&lt;/dd&gt;&lt;/dl&gt; 依然使用上面的样式，则它们会渲染成： 组别1 第一项 第一项的描述 第二项 第二项的描述 组别2 第三项 第三项的描述 flow:row的声明可以在一列中接受一个元素列表。如: 1flow: row(label, input select textarea); 定义了两列，第一列放置了&lt;label&gt;元素，而所有其他的&lt;input&gt;,&lt;select&gt;和&lt;textarea&gt; 元素被放置在第二列。 3.7. flow: stackflow:stack布局用于在容器中的任意位置放置元素。渲染的顺序取决于元素的DOM位置或z-index属性定义的顺序。 在水平和垂直方向上, 被包含元素的width、height、margin、padding的弹性值使用容器元素的宽度和高度来计算。在弹性计算中，没有子元素都被当做容器元素的唯一子元素来对待 - 子元素的位置不会影响其他子元素的位置。 flow:stack容器元素的内在尺寸等同于容器中子元素外边距盒的最宽的和最高值。 考虑下面的HTML代码: 1234&lt;section tab=\"标签页一\"&gt; &lt;div&gt;标签页二&lt;/div&gt; &lt;div&gt;标签页三&lt;/div&gt;&lt;/section&gt; 它的样式为: 1234section &#123; flow: stack; width: max-content; &#125;section &gt; div &#123; size:*; /* 跨越整个容器 */ visibility:hidden; &#125;section[tab=first] &gt; div:nth-child(1) &#123; visibility:visible; &#125;section[tab=second] &gt; div:nth-child(2) &#123; visibility:visible; &#125; 通过修改section元素的 tab属性值，我们可以切换标签页的显隐。 原则上，flow:stack布局在某些方面类似于在position:relative容器中包含position:absolute子元素。不过flow:stack的内在尺寸计算规则是其他CSS属性无法模拟的。 4. flow属性、float属性 和块格式上下文(block formatting context)那些flow属性设置了非默认值的元素的直接子元素，将会建立一个新的块格式上下文，这个上下文类似于表格中的单元格。 5. flow属性 与position属性流元素(flowed element)是指在流容器中的position为静态(默认)的子元素们。这意味着那些包含position: absolute | fixed的子元素会被当做position:static来处理。 在流元素中position:relative 是被允许的。因此，这些元素可以使用left、right、 bottom和top属性来定义它们相对于静态位置的偏移。 5.1 position: absolute | fixed 与 弹性(Flex)单位值弹性单位可以用在定义了position:absolute或position:fixed的元素的left、top、right和bottom属性中，这些元素的内边距(padding), 外边距(margin), 宽度(width)和高度(height)中的弹性单位值的计算将会参考包含它们的父块。 例如：下面的样式将会将#light-box-dialog元素放置在视口(viewport)的中央： 1234567#light-box-dialog&#123; position: fixed; left:1*; top:1*; right:1*; bottom:1*; width: 400px; height: auto;&#125; #light-box-dialog元素的宽度为400像素，高度为自动(即最小内在高度height:min-intrinsic)，且该元素将会放置在视口中央。 6. flow属性与vertical-align属性流元素建立了一个块格式上下文。因此它们的vertical-align属性定义了它们内部垂直方向上的对齐方式，而不是它们本身在垂直方向上的对齐方式。或者说vertical-align类似于表格中的单元格。 7. flow属性与border-spacing属性border-spacing属性定义了两个流元素在水平和垂直方向上外边距的最小值。如果一个流元素定义了自己的外边距，则外边距使用的值是border-spacing定义值和该外边距定义中比较大的那个值。 如果这个外边距值使用了弹性单位值，则该弹性值的计算会将border-spacing值作为最小约束值。在这种情况下，计算出的弹性值不能小于border-spacing属性值。 8. flow属性 与 外边距堆叠不同的布局管理器的对流元素的外边距堆叠处理是不一样的。流容器外边距不会与它内部的硫元素堆叠。 9. flow属性和 行内块(inline-block)元素行内块放置在对应的行框中。原则上，行框是可以”弹性”的。 所以, 像&lt;img&gt;、&lt;input&gt;、&lt;span style=&quot;display:inline-block&quot;&gt;这些inline-block元素可以使用弹性单位来定义它们的尺寸、外边距、内边距。行框上下文的弹性单位计算依据于行框的水平、垂直尺寸，而它们的内容将不是可弹性的。 在水平方向上，行框在分配完所有非弹性内容后可能存在剩余的空间(例如单词框)。这些空间将会在所有指定了弹性值的元素的宽度、左右外边距(或内边距)间分配。 在垂直方向上, 行内块(inline-block)元素的高度、上下外边距、内边距中的弹性值依据于行框的高度。例如，可以定义多个和行框同高度的子元素。 如果这样定义了，text-align:justify属性的计算将会放置弹性值计算之后。 例如下面的HTML标记: 123456789101112131415&lt;style&gt; p &#123; padding:4px; border:2px solid black; line-height:1.8em; &#125; span &#123; display:inline-block; border: 2px solid salmon; background:seashell; &#125;&lt;/style&gt;&lt;p&gt; First span:&lt;span style=\"width:2*\"&gt;width:2*&lt;/span&gt; and second one:&lt;span style=\"width:1*\"&gt;width:1*&lt;/span&gt;&lt;/p&gt; 这回到这p元素各种各样的宽度值： 注意，上面的最后一个图像上，span已经达到了它的最小内在宽度(min-intrinsic)，所以它们已经排除掉了相关的弹性值计算。","tags":[{"name":"Sciter","slug":"Sciter","permalink":"http://suiang.cn/tags/Sciter/"},{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"}]},{"title":"Typora 自定义命令上传图片","date":"2020-09-11T01:57:00.045Z","path":"posts/40698/","text":"背景Typora是我非常喜欢的Markdown编辑器，之前的一个更新，Typora支持了“上传图像”的功能（即写文章时，插入图片自动将其上传至图床），我们可以直接借助IPic、uPic、PicGo等程序，配合Typora自动将图片上传至又拍云等对象存储平台。但是，官方的文档晦涩难懂，我尝试进行了一些配置，但始终还是不好使，那咋办嘛？ 其实，将本地图片上传至图床，这个过程本质上来说就是一条HTTP请求，但是如果这个过程还需要在后台一直开着一个图床软件或者安装一些命令行工具（更何况很多工具也是收费的），代价就有些大了。庆幸的是，Typora支持不借助这些图床工具，通过自定义命令（脚本）的方式，完成自动上传图片的功能。 那么，能不能自己写一个十几行代码的脚本来适配Typora呢？当然可以了。 一起开始吧以Typora自定义命令上传图片为例，当我们从我们插入一张图片时，发生了什么？我们在Typora插入一张本地的图片后，Typora会调用预先设置的自定义命令（通常是运行一个脚本）来上传图片，自定义命令（脚本）上传完图片后输出（注意这里有坑）相应的URL，Typora会读取该URL，并自动把本地图片地址替换为相应的URL。所以只要配置得当，我们在写作时，只需要准备好素材，直接对素材command + c、command + v了。 如果我们要通过自定义命令来上传图片，只需要三步： 编写能够上传图片至相应的图床或者对象存储的脚本 在偏好设置中进行相应的设置 测试是否正常 编写脚本脚本如下所示: 1234@echo offecho Upload Success:if exist %1 curl -F name=@%1 https://img.vim-cn.com/if exist %2 curl -F name=@%2 https://img.vim-cn.com/ 我们在写一个脚本的时候，大体上关注三部分内容，输入、处理过程和输出。处理过程是自己实现的所以还好，但Typora上传图片自定义命令的传参和输出是真的奇坑。 传参。Typora上传图片调用自定义命令时，会将待上传的图片作为命令行参数，传入脚本。如bash upload.sh 1.jpg 2.jpg，这里具体有几张待上传的图片不确定，所以参数长度是不固定的，你的脚本必须上传所有作为参数传入的图片。Typora并没有在文档中直接说明这一点（传参的方式、长度），真的给我坑坏了。 输出。事实上，Typora并不关心我们脚本中上传图片的具体过程如何，它只关心我们脚本的最终输出。Typora要求脚本输出结果的方式简单粗暴，直接echo（其他语言比如Python的print）。注意，直接echo也是有格式要求的，脚本需要首先输出Upload Success:，之后，一行对应一个URL，具体格式如下： 123Upload Success:https://sample.com/1.jpghttps://sample.com/2.jpg 这里，我使用bat脚本，事实上，你可以使用任何变成语言，上传图片至任意的平台。只要你脚本处理好传入的参数，上传完所有图片，最终的输出结果是上面的格式即可。 偏好设置Typora上传脚本支持的自定义命令，可以在偏好设置中选择。上传服务选择Custom Command，自定义命令就是我们插入图片后，Typora调用的命令。如刚才我们的脚本名称为upload.cmd，自定义命令就可以设为upload，注意替换upload的路径为绝对路径。 测试是否正常 完成脚本和偏好设置后，就可以测试脚本是否正常了。打开偏好设置，直接点击验证图片上传选项。 尾巴市面上确实有很多功能丰富的Markdown编辑器，但所见即所得、小巧轻量的Typora依然是我最喜欢的。图片上传功能的加入，极大方便了写作的过程，想想之前，写文章需要手动将图片拖到图床APP，再把URL复制到文章中，就两个字，“繁琐”。 最后，用Typora写作，自定义命令上传图片，自己写一个脚本，四行代码，卸载掉各种图床工具，插入图片直接command + v，写作原本就该这么简单嘛！&copy;","tags":[{"name":"Typora","slug":"Typora","permalink":"http://suiang.cn/tags/Typora/"},{"name":"Markdown","slug":"Markdown","permalink":"http://suiang.cn/tags/Markdown/"}]},{"title":"多线程入门","date":"2020-09-10T18:07:06.447Z","path":"posts/1014/","text":"背景 当你点击EXE文件系统一个应用程序的时候 - 系统会创建一个进程（process）而在一个进程内可以包含多个线程(thread)。用来显示界面的线程，我们通常称为“界面线程”，其他不是用来显示界面的线程，我们一般称为“工作线程”或者是“后台线程”。 界面线程会使用 win.loopMessage(); 启动一个消息循环，win.loopMessage(); 就象一个快递公司不知疲倦的收发消息，直到用户关闭最后一个窗口他才会退出。当然你也可以使用 win.quitMessage() 退出消息循环。 下面是一个启动界面线程的例子： 12345678910111213141516import win.ui;/*DSG&#123;&#123;*/var winform = win.form(text=\"aardio form\";right=759;bottom=469)winform.add( button=&#123;cls=\"button\";text=\"耗时操作\"; ...&#125;)/*&#125;&#125;*///用户点击窗口上的按钮时会触发下面的回调函数winform.button.oncommand = function(id,event)&#123; //下面用sleep函数休眠5秒(5000毫秒)模拟耗时操作 sleep(5000)&#125;winform.show();win.loopMessage(); 你可以看到一个窗体显示在屏幕上，如果你去掉代码中的最后一句 win.loopMessage();那么窗体只会显示一下就消失了，你的程序也迅速退出了。 但如果你加上 win.loopMessage(); 窗体就会一直显示在屏幕上（直到你点击关闭按钮）。并且你可以做其他的操作，例如点击按钮。 我们尝试点击按钮，点击按钮后触发了 winform.button.oncommand() 函数，一件让我们困惑的事发生了，窗体卡死了任何操作都没有反应，这是因为类似 sleep(5000) 这样的耗时操作阻塞了win.loopMessage()启动的消息循环过程。 一种解决方法是把 sleep(5000)改成 win.delay(5000)，虽然他们同样都是延时函数，但是win.delay()会同时继续处理窗口消息。但如果我们不只是延时还要做其他耗时的操作，那就需要启动一个新的线程。 创建线程 一个线程会排队执行一系列的编程指令，但一个线程同时只能做一件事。例如在界面上有耗时的操作在执行时 - 就不能同时处理其他的界面消息或者响应用户的操作。这时候我们就要使用多线程来完成我们的任务。 我们假设有一个耗时操作是这样的： 1234567891011//下面这个函数执行耗时操作doSomething = function( str )&#123; for(i=1;100)&#123; str = str + \" \" + i; sleep(100) &#125; return 123; &#125; 一般我们直接调用这个函数会是这样写：1doSomething( \"也可以有参数什么的\" ) 如果希望写复杂一点调用这个函数，我们也可以这样写：1invoke(doSomething ,,\"也可以有参数什么的\" ) 如果我们希望创建一个新的线程来调用这个函数，那么就需要下面这样写：1thread.invoke(doSomething ,\"也可以有参数什么的\" ) 切记不要犯一个低级错误： 如果把创建线程的代码改为 thread.invoke( doSomething(&quot;也可以有参数什么的&quot;) )这是在创建线程前就调用函数了，实际执行的代码是 thread.invoke( 123 ) 这肯定会出错的。 线程的规则与限制 线程有独立的运行上下文，独立的变量环境 多线程最让人困惑的是线程间的同步和交互。 线程就象多个在并列的轨道上疾驰的火车，你要在A火车上与B火车上的人交互，或者你想让B火车上的人干什么，你不能直接从火车上把手伸出去跟别的火车上的人拉拉扯扯发生种种亲密的互动。 一种方式是先让所有的火车都停下来，互动完了再继续往前开，需要互动的时候再停下来，这通常需要用到线程同步的锁，在aardio中就是thread.lock()，但实际上在aardio中多线程同步很少需要用到同步锁，所以这里我也就不多讲。 另外一种更先进的方式就是TLS(Thread Local Storage)，也就是线程局部存储。一些编程语言的全局变量是多线程共享的，一次修改多个线程中立即生效，这看起来很方便，其实带来的潜在麻烦会很多，会制造大量混乱的BUG。而aardio自带TLS, 所有变量都是线程局部存储。你不能在多线程间直接共享变量。 交换变量的方法 如果你有一些函数需要被多个线程用到，请他们写到库文件里，然后在任何线程中使用 import 语句导入即可使用。 可以在创建线程时，通过线程的启动参数把变量从一个线程传入另一个线程，例如： 1thread.invoke( 线程启动函数,\"给你的\",\"这也是给你的\",\"如果还想要上车后打我电话\" ) 多线程共享的变量，必须通过 thread.get() 函数获取，并使用 thread.set() 函数修改其值，thread.table对象对这两个函数做了进一步的封装（伪装成一个普通的表对象） aardio提供了很多线程间相互调用函数的方法，通过这些调用方式的传参也可以交互变量，具体请查看aardio范例中的多线程范例。 交换变量的规则在aardio中每个线程有独立的运行上下文、线程有独立的变量环境，有独立的堆栈，所以你不能把包含局部变量闭包的对象从一个线程传到另一个线程，常见的就是调用类创建的对象，因为this就是闭包变量。 另外你也不可以在一个线程中引用库文件，并且把引用的库直接传到另一个线程，因为库文件中通常会大量的使用局部变量闭包，而应该在每个线程中自行导入需要用到的库，一个例子： 12345678910import console;thread.invoke( function()&#123; import console; console.log(\"线程要自己调用 import console;\") &#125;)console.pause(true); 调用窗口对象新手可能不太容易理解，aardio中的这种模式给多线程开发带来了巨大的方便，在aardio的多线程代码中基本很少看到同步锁，也很少会因为同步出现各种BUG和麻烦，以前面并列飞奔的多个火车来比喻，在aardio中每辆火车都只要愉快的往前跑就行了，不存在谁停下来等谁同步的问题。 但不可否认，工作线程中如果能直接操作窗口上的控件那会带来巨大的方便（因为工作线程需要访问界面控件的需求还是非常多的），但这违反了aardio的规则，在aardio的旧版本中这是行不通的，在aardio新版本中，我们愉快的解决了这个问题。现在aardio中可以存在一些特权对象，让一些不能在线程中直接传递的对象可以跨线程传递，例如窗口对象，下面我们看一个例子： 1234567891011121314151617181920import win.ui;var winform = win.form(text=\"aardio form\";right=759;bottom=469)winform.add( button=&#123;cls=\"button\";text=\"再来个多线程，可以多点几次不会乱的\"; ...&#125;; edit=&#123;cls=\"edit\";edge=1;multiline=1;z=1; ...&#125;)winform.button.oncommand = function(id,event)&#123; thread.invoke( function(winform)&#123; for(i=1;10;1)&#123; winform.edit.print( time.tick(),\"线程ID:\",thread.getId() ); sleep(1000) &#125; &#125;,winform )&#125;winform.show()win.loopMessage(); 注意上面的线程启动函数直接写在了参数里（匿名函数），跟下面的写法作用是一样的： 12345678910//下面这个函数执行耗时操作var doSomething = function( winform )&#123; for(i=1;10;1)&#123; winform.edit.print( time.tick(),\"线程ID:\",thread.getId() ); sleep(1000) &#125;&#125;thread.invoke( doSomething,winform ) //启动线程 界面与逻辑分离在工作线程中直接操作界面控件固然令人愉快，但如果代码量一大，界面与逻辑混杂在一起，会让代码不必要的变的千头万绪复杂臃肿。 如果把多线程比作多条轨道上并列飞奔的火车，那么火车交互的方法不仅仅只有停下来同步，或者把手伸出车窗来个最直接的亲密交互。一种更好的方式是拿起手机给隔壁火车上的人打个电话 - 发个消息，或者等待对方操作完了再把消息发回来。 这种响应式的编程方式在aardio里就是 thead.command，下面我们看一个简单的例子： 12345678910111213141516171819import win.ui;var winform = win.form(text=\"线程命令\";right=599;bottom=399)winform.add(edit=&#123;cls=\"edit\"; ...&#125;)import thread.command;var listener = thread.command();listener.print = function( ... )&#123; winform.edit.print( ... ) //我们在界面线程中这样响应工作线程的消息&#125;thread.invoke( //创建工作线程 function()&#123; import thread.command; //必须在线程函数内部导入需要的库 thread.command.print(\"hello world\",1,2,3); //调用界面线程的命令 &#125;)winform.show();win.loopMessage(); thread.command可以把多线程间复杂的消息交互伪装成普通的函数调用，非常的方便。 这里新手仍然可能会困惑一点：我在工作线程中不是可以直接操作界面控件么？！ 你这个thread.command虽然好用，但是多写了不少代码呀。 这样去理解是不对的，你开个轮船去对象菜市场买菜固然是有点麻烦，但如果你开轮船去环游世界那你就能感受到它的方便在哪里了。thread.command 一个巨大的优势是让界面与逻辑完全解耦，实现界面与逻辑的完全分离，当你的程序写到后面，代码越来越多，就能感受到这种模式的好处了。 例如 aardio自带的自动更新模块的使用示例代码： 1234567891011121314151617181920import fsys.update.dlMgr;var dlMgr = fsys.update.dlMgr( \"http://update.aardio.com/api/v1/version.txt\",\"/download/update-files\")dlMgr.onError = function(err,filename)&#123; //错误信息 err,错误文件名 filename 这里可以不用做任何处理,因为出错了就是没有升级包了&#125;dlMgr.onConfirmDownload = function(isUpdated,appVersion,latestVersion,description)&#123; if( ! isUpdated )&#123; //已经是最新版本了 &#125; else &#123; //检测到最新版本，版本号 latestVersion &#125;; return false; //暂不下载&#125;dlMgr.create(); 这个fsys.update.dlMgr里面就用到了多线程，但是他完全不需要直接操作界面控件。而你在界面上使用这个对象的时候，你甚至都完全不用理会他是不是多线程，不会阻塞和卡死界面，有了结果你会收到通知，你接个电话就行了压根不用管他做了什么或者正在做什么。 这个fsys.update.dlMgr里面就是使用thread.command实现了实现界面与逻辑分离，你可以把检测、下载、更新替换并调整为不同的界面效果，但是fsys.update.dlMgr的代码可以始终复用。 使用线程句柄一般我们可以使用 thread.invoke() 函数简单快捷的创建线程，而 thread.create() 的作用和用法与 thread.invoke() 一样，唯一的区别是 thread.create()会返回线程句柄。 线程句柄可以用来控制线程（暂停或继续运行等等），如果不再使用线程句柄，应当使用 raw.closehandle() 函数关闭线程句柄（这个操作不会关停线程） 有了线程句柄，我们可以使用 thread.waitOne() 等待线程执行完毕，而且 thread.waitOne() 还可以一边等待一边处理界面消息（让界面不会卡死）。 下面看一下aardio范例里的多线程入门示例： 123456789101112131415161718192021222324252627282930313233343536373839import console;var thrdHandle = thread.create( function()&#123; import console; thread.lock(\"写控制台\",function()&#123; console.log(\"线程在执行\",thread.getId() ) &#125;) //这里如果高级点可以用 thread.event来实现信号判断,参考本目录下的定时器范例 while(!thread.get(\"红灯停\"))&#123; console.log(\"线程在执行\",time() ) sleep(1000) &#125; console.log(\"停了!\") &#125;) thread.suspend(thrdHandle) //使用线程句柄就可以控制线程,例如下面的函数暂停线程thread.resume(thrdHandle) //线程恢复运行var act = thread.stillActive(thrdHandle) //线程是否在运行sleep(3000)//每个线程的全局变量环境都是独立的,而 thread.set() 则用于设置所有线程共享的全局变量。thread.set(\"红灯停\", true)thread.waitAll(thrdHandle)//句柄不用的时候一定要用下面的函数关闭(切记：句柄是绝对不会自动释放的),关闭句柄并不会关闭线程raw.closehandle(thrdHandle)thread.invoke( function()&#123; import console; console.log(\"线程在执行\",thread.getId() ) &#125;)sleep(100)console.pause(true); 您可以使用 thread.command 在线程间交互通信,请参考《多线程开发入门》您还可以使用 thread.event 来实现线程间的同步,请参考《多线程中的交通信号灯：thread.event》或者使用 thread.works、thread.manage 这些线程管理器来批量的管理线程句柄,请参考此目录中的其他范例。 管理多线程aardio中提供了 thread.manage，thread.works 等用于管理多个线程的对象，例如标准库中用于实现多线程多任务下载文件的 thread.dlManager 就使用了thread.works管理线程。 thread.works 用于创建多线程任务分派，多个线程执行相同的任务，但可以不停的分派新的任务， 例子： 1234567891011121314151617181920212223242526272829303132333435363738import console;import thread.works;var works = thread.works( 20, function(...) &#123; import console; thread.lock(\"写控制台\") console.log(\"线程ID\" + thread.getId(),\",开始工作,接收到任务指令参数\",...) thread.unlock(\"写控制台\") return \"返回值,线程ID\" + thread.getId(); &#125;);//分派任务works.push(\"一个任务\")works.push(\"两个任务\")//等待任务完成works.wait( function(r)&#123; console.log( \"检查成果\", r ) &#125;)works.push(\"三个任务\")works.push(\"四个任务\")works.push(\"五个任务\")//退出程序前,等待任务完成并关闭所有线程works.waitClose( function(r)&#123; console.log( \"检查成果\", r ) &#125;)execute(\"pause\") 而 thread.manage 可以用来创建多个线程执行多个不同的任务，可以添加任意个线程启动函数，在线程执行完闭以后可以触发onEnd事件，并且把线程函数的返回值取回来， 示例如下： 1234567891011121314151617181920212223242526272829303132import console;import thread.manage//创建线程管理器manage = thread.manage(3)var thrdFunc = function(name)&#123; import win; import console; for(i=1;10;1)&#123; console.log( thread.getId(),name ) if( !win.delay(1000) )&#123; //主线程可以用 manage.quitMessage()中断这个循环 console.log(\"收到退出指令\") return; &#125; &#125; return 67;&#125;manage.create(thrdFunc,\"线程1\").onEnd = function(...)&#123; console.log(\"线程1的回调\",...)&#125;manage.createLite(thrdFunc,\"线程2\").onEnd = function()&#123; console.log(\"线程2的回调\")&#125;manage.create(thrdFunc,\"线程3\")manage.waitClose()console.pause(); thread.manage通常是用于界面线程里管理工作线程，上面为了简化代码仅仅用到了控制台。 获取线程返回值我们有时候在界面中创建一个线程，仅仅是为了让界面不卡顿，我们希望用 thead.waitOne() 阻塞等待线程执行完闭（界面线程同时可以响应消息），然后我们又希望在后面关闭线程句柄，并获取到线程最后返回的值。 可能我们希望一切尽可能的简单，尽可能的少写代码，并且也不想用到thread.manage（因为并不需要管理多个线程）。 这时候我们可以使用 win.invoke，win.invoke 的参数和用法与 thread.invoke完全一样，区别是 win.invoke 会阻塞并等待线程执行完毕，并关闭线程句柄，同时获取到线程函数的返回值。 示例： 12345678910111213141516171819import win.ui;var winform = win.form(text=\"aardio form\";right=759;bottom=469)winform.add( button=&#123;cls=\"button\";text=\"读取网页\";z=1; ...&#125;; edit=&#123;cls=\"edit\";text=\"edit\";edge=1;multiline=1;z=2; ...&#125;)winform.button.oncommand = function(id,event)&#123; winform.edit.text = win.invoke( function()&#123; import inet.http; sleep(3000);//暂停模拟一个耗时的操作 return inet.http().get(\"http://www.aardio.com\"); &#125; )&#125;winform.show()win.loopMessage(); 代码运行测试一下，在线程执行完以前，你仍然可以流畅的拖动窗口，操作界面。 写在最后 重视范例，才能开箱即用！ 教程中用到的多线程直接调用窗口对象的功能 - 需要更新到新版 aardio才能支持。更多关于多线程的功能请大家看aardio范例和文档。 一些用户可能不明白 aardio怎样才能真正的“开箱即用”，我接触到的一些用户拿起aardio就可以直接使用，写出非常好的程序而且速度很快，他们高兴的表示aardio简洁轻巧不用特别的学习直接就可以使用，而另外一些却始终在犹豫，在到处找教程、找文档，始终找不到方法，每前进一步都要求你准备一大堆的说明书才敢向前迈一步，实际上我发现他们换其他编程工具也是类似的结果（ 可能有极少数学步车式的开发工具他们会适应 ）。 我也跟那些上手比较快的用户聊过一些，发现他们都有一个共同的习惯就是非常重视范例，因为 aardio的范例非常、非常的多，而且aardio范例跟其他语言都有一些不同，很多代码就是几句代码就是一个简单而完整的程序，我经常听到一些人跟我说，仅仅是复制一些范例整合到一起，做一些修改就可以做出软件。 所以请记住：教程写的再多，看的再多，始终是纸上谈兵。 搞培训的人很愉快因为能赚到钱，而参加培训的人也很愉快因为找到了心理安慰剂，但真正能让你学会编程的是多看范例，多跑代码，多动手写代码！","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"}]},{"title":"AArdio 调用Go语言","date":"2020-09-10T16:59:13.915Z","path":"posts/48288/","text":"go语言自带的jsonrpc 不支持http/websocket，而是使用tcp协议，aardio中增加了一个库 wsock.tcp.jsonClient 支持与go语言进行jsonrpc调用。 先使用go语言编写一个exe文件（ 当然你可以把后缀名改为 dll，下面的代码一样可以运行 ）go语言代码如下，注意 go里面{换行写是语法错误 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( \"fmt\" \"log\" \"net\" \"net/rpc\" \"net/rpc/jsonrpc\")type Args struct &#123; X, Y int&#125;var listener net.Listenertype Calculator struct&#123;&#125;func (t *Calculator) Add(args *Args, reply *int) error &#123; *reply = args.X + args.Y return nil&#125;func (t *Calculator) Exit(args *int, reply *int) error &#123; listener.Close() return nil&#125;func main() &#123; cal := new(Calculator) server := rpc.NewServer() server.Register(cal) listener, e := net.Listen(\"tcp\", \"localhost:0\") if e != nil &#123; fmt.Printf(\"error:%s\\n\", e) return &#125; else &#123; fmt.Printf(\"%s\\n\", listener.Addr().String()) &#125; for &#123; if conn, err := listener.Accept(); err != nil &#123; log.Fatal(\"error: \" + err.Error()) &#125; else &#123; go server.ServeCodec(jsonrpc.NewServerCodec(conn)) &#125; &#125;&#125; 假设上面用go语言生成的exe文件名为gotest.exe，并且是放在当前工程目录下，然后我们用下面的 aardio 代码调用这个 gotest.exe 里的go函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import win.ui;/*DSG&#123;&#123;*/var winform = win.form(text=\"aardio调用go语言演示\";right=759;bottom=469)winform.add(button=&#123;cls=\"button\";text=\"调用Go语言的Calculator.Add函数\";left=382;top=389;right=678;bottom=427;z=5&#125;;edit=&#123;cls=\"edit\";left=19;top=12;right=732;bottom=352;edge=1;hscroll=1;multiline=1;vscroll=1;z=1&#125;;editX=&#123;cls=\"edit\";text=\"2\";left=109;top=392;right=185;bottom=424;edge=1;z=2&#125;;editY=&#123;cls=\"edit\";text=\"3\";left=238;top=392;right=320;bottom=420;edge=1;z=3&#125;;static=&#123;cls=\"static\";text=\"+\";left=198;top=395;right=230;bottom=420;align=\"center\";transparent=1;z=4&#125;)/*&#125;&#125;*/import wsock.tcp.jsonClient;import process.popen;//gotest.exe是使用go语言编写的exe文件。var gofile = process.popen(\"/gotest.exe\");if(!gofile) return winform.msgbox(\"启动go程序失败\");//读取服务端地址(使用自动分配的空闲端口避免冲突)var url = gofile.read();if( !url || string.startWith(url,\"error:\") ) return winform.msgbox(\"启动go程序失败\");//连接go语言服务端var go = wsock.tcp.jsonClient(url)winform.edit.print(\"已连接到go程序\",url);winform.button.oncommand = function(id,event)&#123; //调用go语言提供的函数 var rep = go.Calculator.Add(&#123; X = tonumber(winform.editX.text); Y = tonumber(winform.editY.text); &#125; ) if( rep[[\"result\"]] )&#123; winform.edit.print( \"调用成功\", rep.result ) &#125; else &#123; winform.edit.print( rep[[\"error\"]] ) &#125;&#125;winform.show()win.loopMessage();//通知go程序退出go.Calculator.Exit(0); 附：调用Go语言编译器例子 12345678910111213import console;import golang;var go = golang();go.runCode(\"/hello.go\",`package mainimport \"fmt\"func main() &#123; fmt.Println(\"hello world\")&#125;`)console.pause(); 最新版golang扩展库已支持自动下载配置Go编译器。Go最新版已经支持调用生成DLL文件（需要调用gcc），在aardio中可以直接调用Go生成的DLL文件（使用cdecl调用约定），下面是调用Go编译器生成DLL的演示。 下面看演示： 1234567891011121314151617181920212223242526272829303132333435import console;import golang;//创建Go编译器var go = golang();//Go源码与字符串都是UTF-8编码，跟aardio一样很方便string.save(\"/hello.go\",`package mainimport \"C\"import \"fmt\"//export SayHellofunc SayHello(name string) &#123; fmt.Printf(\"Go says: %s!\\n\", name)&#125;func main() &#123; //DLL入口函数,没有也要写个空的&#125; `)//编译Go源码生成DLL文件go.buildShared(\"/hello.go\",\"/hello.dll\");//加载Go编译的DLL，注意要指定cdecl调用约定var dll = raw.loadDll(\"/hello.dll\",,\"cdecl\");//直接就可以调用DLL里的函数，不用声明console.open();var str = \"必须在Go函数名前面加上 export 函数名的注释才能导出函数\";dll.SayHello(str,#str);console.log( n )console.pause(); Go写DLL要注意一个特别的地方，Go导出函数前必须写一行注释声明导出函数，例如上面的 //export SayHello Go语言里的字符串GoString是一个结构体，用aardio来表示是这样的： 12345678class goString&#123; ctor( str )&#123; this.s = str; this.n = #str; &#125;; string s; addr n;&#125; 如果是在API函数里传值，一个GoString展开为2个API参数来表示就可以了（一个字符串，后面跟一个字符串长度） 因为aardio传结构体都是传指针，如果用结构体，在Go里面要声明为指针，示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243import console;import golang;//创建Go编译器var go = golang();//Go源码与字符串都是UTF-8编码，跟aardio一样很方便string.save(\"/hello.go\",`package mainimport \"C\"import \"fmt\"//export SayHellofunc SayHello(name *string) &#123; fmt.Printf(\"Go says: %s!\\n\", *name)&#125;func main() &#123; //DLL入口函数,没有也要写个空的&#125; `)//编译Go源码生成DLL文件go.buildShared(\"/hello.go\",\"/hello.dll\");//加载Go编译的DLL，注意要指定cdecl调用约定var dll = raw.loadDll(\"/hello.dll\",,\"cdecl\");class goString&#123; ctor( str )&#123; this.s = str; this.n = #str; &#125;; string s; addr n;&#125;//直接就可以调用DLL里的函数，不用声明console.open();dll.SayHello( goString( \"必须在Go函数名前面加上 export 函数名的注释才能导出函数\") );console.log( n )console.pause(); 需要先安装MinGW( GCC ) 可以下载安装 MinGW-W64: https://sourceforge.net/projects/mingw-w64 这个只能安装在64位系统。也可以下载安装 TDM-GCC: http://tdm-gcc.tdragon.net/download 这个提供支持32位、64位安装包。 golang扩展库会自动搜索MinGW,MinGW-W64,TDM-GCC的安装位置，不需要手动配置。当然也可以调用golang扩展库提供的addPath函数自己添加gcc.exe所在的目录。 Go生成的文件很大，加上-ldflags &quot;-s -w&quot;参数会小一些，go.buildShared() 已经自动加上这些参数。编译上面的代码生成的DLL只有1MB多一点，而且可以支持WinXP，不需要依赖外部运行库，还是非常不错的。而且测试了一下，编译的DLL还能内存加载。","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"},{"name":"Golang","slug":"Golang","permalink":"http://suiang.cn/tags/Golang/"}]},{"title":"使用 web.rest 调用 REST API","date":"2020-09-10T16:59:13.914Z","path":"posts/11315/","text":"web.rest下面的支持库最简单的用法就是作为一个 HTTP客户端使用，该客户端对象简化了get,post,put,patch,delete 等常用的 HTTP请求操作，并提供编码请求数据、解码返回数据的功能。 标准库中用于调用 REST API 的库： web.rest.client 请求参数使用urlencode编码,服务器返回文本数据。 web.rest.xmlClient 请求参数使用urlencode编码,服务器返回xml格式数据。 web.rest.jsonLiteClient 请求参数使用urlencode编码,服务器返回JSON格式数据。 web.rest.jsonClient 请求参数与服务器返回数据都使用JSON格式。 除了与服务器交互的数据格式不同以外, 这几个库的接口用法完全一样，可以看看这几个库的源码实际上他们都是调用 web.rest.client 这一个库。 基本的 HTTP 请求web.rest下面的支持库最简单的用法就是作为一个HTTP客户端使用，该客户端对象简化了get,post,put,patch,delete等常用的HTTP请求操作，并提供编码请求数据、解码返回数据的功能，下面是一个最简单的示例： 1234567891011import console;import web.rest.jsonLiteClient;var restClient = web.rest.jsonLiteClient();var jsonData = restClient.post(\"http://httpbin.org/post\", &#123; 用户名 = \"用户名\"; 密码 = \"密码\";&#125;)console.dumpJson(jsonData)console.pause(true); 从上面的示例可以看出，我们上传参数的是aardio中的对象，返回的数据也被自动解码为aardio对象，虽然 HTTP传输使用的是 JSON 数据，但使用时不需要去管 JSON 的编解码等一系列的操作。 转换为 AArdio 函数web.rest 不仅仅可以用来做上面这些简单的 HTTP请求、以及编解码的操作，他还可以将基本符合 REST风格的 Web API转换为aardio中的函数对象，这非常有意思，REST本身不是一个严格的规范、更缺乏WebService那样的WSDL接口描述服务，但是aardio设计了一种简单可行的声明语法，可以非常方便的把混乱的 Web API转换为统一的 aardio函数。 首先我们看一下 REST API的 URL 一般会是这种格式 http://主机/资源目录名/资源目录名/资源名aardio的web.rest库模块中的客户端对象提供一个 api 函数用于声明一个API接口，api 函数的定义如下： var restApi = restClient.api(&quot;接口URL描述&quot;,&quot;默认HTTP请求动词&quot;) 其中接口URL描述可以直接指定一个web api的网址，在该网址中还可以使用变量，变量放在花括号中，例如：http://主机/{变量名}/资源目录名/资源名 aardio并不关心变量名的内容是什么，只关心它们出现的前后顺序，当调用restApi的成员函数时会使用函数名替换接口 URL 中的变量生成新的请求URL。 下面是一个简单的示例：123456789101112131415161718192021import console;import web.rest.jsonClient;// 创建REST客户端var restClient = web.rest.jsonClient();//声明一个API接口,第一个参数指定URL描述var restApi = restClient.api(\"http://httpbin.org/api/&#123;program&#125;/&#123;lang&#125;\")/*下面调用接口函数，在请求时下面代码中的接口名\"language\"替换接口URL描述中的变量&#123;program&#125;接口名\"aardio\"则替换接口URL描述中的变量&#123;lang&#125;最后生成的请求URL为 http://httpbin.org/api/language/aardio */var result = restApi.language.aardio()console.log(\"请求的URL\", restClient.lastRequestUrl)restClient.lastResponse(); //输出服务端最后返回的数据console.pause(); 接口 URL中连接的变量名还可以合并为{...}例如 http://httpbin.org/api/{program}/{lang} 可以简写为 http://httpbin.org/api/{...}当 {...} 出现在尾部时还可以直接省略，例如 http://httpbin.org/api/ 注意head,get,post,put,patch,delete等默认的HTTP请求操作作为函数名时不会被添加到生成的URL中。 这些默认的HTTP方法名在 web.rest.client._defaultMethod 中指定，例如使用 restApi.language.get() 显示的指定 HTTP请求动词为GET。如果不指定 HTTP请求动词，则使用调用 restClient.api(&quot;接口URL描述&quot;,&quot;默认HTTP请求动词&quot;) 函数时第二个参数指定的 HTTP请求动词，不指定该参数时默认为POST。 HTTP规定了九种动词（Verbs）用于指定请求方法：GET,HEAD,POST,DEBUG,PUT,DELETE,PATCH,OPTIONS，而在REST API中用到的有五种 GET，POST，PUT，DELETE，PATCH，他们的用途如下： GET：用于获取数据 POST: 用于创建数据 PUT: 用于替换数据、也可用于更新数据 DELETE: 用于删除数据 PATCH：用于更新数据 上传下载文件如果一个REST API在请求时需要上传、下载文件，那么所有调用规则如前不变。你仅仅需要做的是，在调用API以前指定接受、或发送文件的回调函数以获取上传、下载的进度。 上传文件示例： 12345678restClient.sendFile( \"上传文件路径\" ,function(str,sendSize,contentLength)&#123; ..io.print(\"正在上传\",sendSize,contentLength); &#125;); //在后面再简单的调用API就可以了，例如restApi.upload() 下载文件示例： 12345678restClient.receiveFile( \"上传文件路径\" , function(str,receiveSize,contentLength)&#123; ..io.print(\"正在下载\",receiveSize,contentLength); &#125;); //在后面再简单的调用API就可以了，例如restApi.download() web.rest 也可以支持 multipart/form-data 编码上传文件，示例： 12345678910111213import console; import web.rest.client;var http = web.rest.client(); http.sendMultipartForm( &#123; file = \"@d:\\文件路径\"; username = \"测试\"; &#125;,function(str,sendSize,contentLength)&#123; console.log(\"正在上传\",sendSize,contentLength); &#125; );var str =http.post(\"http://httpbin.org/post\") console.pause(,str) 客户端对象的错误处理web.rest 客户端对象的错误处理与inet.http相同：请求成功返回服务器数据，失败返回空值,错误信息，错误代码等。 注意下面为了演示所有的细节，代码写的比较长，实际开发中不必要写的这么细 12345678910111213141516171819202122232425262728293031323334353637383940414243import console;import web.rest.jsonLiteClient;var restClient = web.rest.jsonLiteClient();/*web.rest客户端对象所以执行HTTP请求的函数遵守以下规则：如果成功:则第一个返回值jsonData为服务端返回数据解码并创建的aardio对象。在HTTP请求遇到错误时:第一个返回值jsonData为空，第二个返回值errMsg为错误信息,返回值errCode为错误代码一般我们可以省略errMsg，errCode这两个返回值不用写，直接判断返回值是否为空即可。 */var jsonData, errMsg, errCode = restClient.post(\"http://httpbin.org/post\", &#123; 用户名 = \"用户名\"; 密码 = \"密码\";&#125;)//jsonData非空为请求成功if (jsonData) &#123; console.dumpJson(jsonData);&#125; else &#123; /* 出错了，如果restClient.lastStatusCode非空则说明服务端返回了HTTP状态代码 */ if (restClient.lastStatusCode) &#123; console.log(restClient.lastStatusMessage()) //查看该状态码的说明 restClient.lastResponse() //输出服务端最后返回的信息 &#125; else &#123; //这通常是没有成功发送请求，在请求到达服务器以前就出错了 console.log(\"HTTP请求遇到错误,WinInet错误代码：\", errCode) console.log( '关于WinInet错误代码的详细说明：\\n http: //support.microsoft.com/kb/193625' ) &#125;&#125;console.pause(); 当然上面的代码一般在调试故障时才需要，一般没必要把错误处理写的这么细，上面的代码也可以简化如下： 123456789101112131415161718import web.rest.jsonLiteClient;var restClient = web.rest.jsonLiteClient();var 鸭子 = restClient.post(\"http://httpbin.org/post\", &#123; 用户名 = \"用户名\"; 密码 = \"密码\";&#125;)if (鸭子[[\"翅膀\"]]) &#123; //这句相当于 if( 鸭子 and 鸭子.翅膀 ) io.print(\"不管服务器给我的是什么鸭子，总之有翅膀的都是好鸭子\")&#125; else &#123; /* 我的网络错误处理模块.错误统一分析( \"怎么回事没翅膀还能叫鸭子吗？\" , restClient.lastStatusCode ) */ return null, \"网络错误\"&#125; 服务端接口设计原则本文参考了 REST API的设计风格、但有部分规则有所变通。在实践中 REST API 完全符合REST规则的比较少见，我在设计 web.rest.client 试图编写一个尽可能通用的支持库、但是发现REST API的实现真是五花八门，而且也缺乏一个统一的接口描述规则。 如果你需要为你的aardio客户端程序设计自己的Web API，那么参考下面的几条原则去实现服务端接口 - 这可以让标准库里 web.rest.client 方便的支持该API( 请参考：使用 web.rest 调用 REST API ). 资源定位路径URL应用于清晰的展现资源定位路径，目录应当使用清晰的资源名称，并可以使用统一的URL接口描述语法声明该API。 例如：http://主机/资源分类/资源目录/资源名/资源ID 原则上不应当把资源名放在URL参数里， 但是要使用这样的友好URL在现实中是用一定代价的，对于一般的Web服务器这可能需URL重写,有一定的性能负担。所以也可以将资源名放到URL参数里，例如 HTTP://主机/资源分类?资源目录=目录名&amp;资源名=资源名&amp;资源ID=资源ID 要注意这里的资源定位有关的参数应当直接放到URL的参数里也就是?号后面，要将资源定位的参数与HTTP提交的参数分开来( 如果你用过 web.rest.client 就知道为什么要这样做 )，并且要按资源定位关系决定参数出现的先后关系。 最后生成的URL要能使用以下的URL描述规则:URL中的资源名应当能使用{模板变量}代替、{模板变量}的先后关系应当对应资源名的出现顺序。{模板变量}包含在花括号里 - 可以使用多个数字或字母，数值的大小并不重要，URL描述仅关心资源出现的先后关系。可以使用 {...} 表示不定个数的模板变量。 http://主机/资源分类/资源目录/资源名/资源ID 使用URL描述语法转换结果就是这样： http://主机/{res}/{category}/{name/{id} 也可以使用 http://主机/{res}/{…} 表示。如果 {...} 出现在最后则可以省略 HTTP://主机/资源分类?资源目录=目录名&amp;资源名=资源名&amp;资源ID=资源ID使用URL描述语法转换以后： HTTP://主机/{res}?资源目录={category}&amp;资源名={name}&amp;资源ID={id} 可以看到资源名是不是写到参数里都能清晰的展现资源定位，要注意 Web API 并不是浏览器，URL并不会出现在浏览器的地址栏，设计一个友好的 API URL 重要的是编程语言里能不能更好的理解并自动分析转换。 例如aardio中的 web.rest.client 就按照这种 URL 描述语法自动的将 URL 描述转换为aardio中的函数对象。 不包含动词原则上URL不应当包含动词，使用HTTP协议的指令动词表示要执行的操作: GET: 表示获取资源POST: 表示新增数据PUT: 表示替换数据DELETE: 表示删除数据PATCH: 表示更新数据 一般的Web服务器因为安全方面的考虑对HEAD、GET、POST之外的请求有所限制, 很多API用POST替代PUT,DELETE的功能，而又要做到URL中不出现动词，就背离了REST的初衷了。 因此建议可选在URL资源定位的最可选性的添加扩展的操作动词，例如：http://host/group/user/userid/ 使用get读取用户信息http://host/group/user/userid/password/change 使用扩展的change方法修改用户密码 如果按这种规则实现服务端的API，那么在aardio里用 web.rest.client 调用起来就很方便，示例： 123456789101112import web.rest.jsonClient;var client = web.rest.jsonClient()var api = client.api(\"http://host/&#123;group&#125;/&#123;..&#125;\")// GET方法读取用户信息var userInfo = api.xgroup.user[userId].get()// 使用扩展的change方法修改密码api.xgroup.user[userId].passord.change( pwd = \"旧密码\"; newPwd = \"新密码\";) 为什么不直接在每一个请求里写具体的URL呢？要考虑到实现一个API的扩展库，API服务端的地址可能发生变更，使用上面的方法就可以简单的维护一个声明URL参数即可。 不出现文件后缀名Web API 的URL中不应出现文件后缀名：例如： http://host/x/y.php 应当在服务器上移动到 http://host/x/y/index.php ，然后提供给客户端的API应隐藏默认的文档名，即 http://host/x/y/ 这样的好处是服务端变更实现会非常方便。 不出现 IP 地址Web API 的URL中不应出现IP地址，即使是测试期间，也应尽可能的使用域名替代IP地址。","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"},{"name":"Web","slug":"Web","permalink":"http://suiang.cn/tags/Web/"}]},{"title":"使用 GitHub 搭建个人博客","date":"2020-09-10T16:59:13.908Z","path":"posts/48270/","text":"Hexo , 一个简单地、轻量地、基于 Node 的一个静态博客框架。下面介绍下如何使用 hexo 和 github pages 搭建个人博客。 准备工作 注意：本文针对Windows平台和Hexo 3.2.2 123456$ hexo -vhexo: 3.2.2hexo-cli: 1.0.2os: Windows_NT 10.0.14393 win32 x64http_parser: 2.7.0node: 6.10.1 安装 Github For Windows主要使用 git bash，如果对 git 命令不熟悉的也可以使用 git 客户端进行某些操作Github For Windows 安装 node.js因为要使用 npm，比较简单的方法就是安装 node.js 安装完成后添加 Path 环境变量，使 npm 命令生效;C:\\Program Files\\nodejs\\node_modules\\npm 创建 Github Pages没有Github 账号的话，需要注册一个，然后创建一个仓库，名字是[yourGithubAccount].github.io 配置 ssh key使用 git bash 生成 public ssh key, 以下是最简单的方法 1$ ssh-keygen -t rsa 然后在 C:\\Users\\[用户名]\\.ssh 目录下会生成 id_rsa.pub ，将内容完全复制到 Github Account Setting 里的 ssh key 粘贴即可。 测试 123$ ssh -T git@github.comHi [yourGithubAccount]! You&apos;ve successfully authenticated,but GitHub does not provide shell access. 设置用户信息 12$ git config --global user.name &quot;[yourName]&quot;//用户名$ git config --global user.email &quot;[yourEmail]&quot;//填写自己的邮箱 经过以上步骤，本机已成功连接到 github，为部署打下基础。 配置 Hexo本地 clone创建本地目录，然后使用 git bash 或者客户端 clone 之前创建的仓库[yourGithubAccount].github.io 安装、配置 Hexo进入仓库目录，使用 npm 安装配置 hexo 123$ npm install -g hexo-cli$ npm install hexo --save$ hexo init 安装 Hexo 插件 12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save 安装 ejs， 否则无法解析模板 1$ npm install ejs 安装 hexo 所需的依赖模块1npm install 然后运行下面的命令生成 public 文件夹 12$ hexo g$ hexo s 在浏览器输入 localhost:4000 本地查看效果 主题hexo 有很多主题可选，我选了 indigo，Material Design 风格的Hexo主题，基于 Hexo 3.0+ 制作。支持多说评论、网站统计、分享等功能，只要稍微配置即可使用。可以根据自己需求进行选择。 使用 hexo部署配置 _config.yml 1234deploy: type: git repository: git@github.com:[yourGithubAccount]/[yourGithubAccount].github.io.git branch: master 1$ hexo d 即可将 hexo 部署到 github 上 提示找不到 git 时 需执行（虽然之前已经执行过） 1npm install hexo-deployer-git --save 然后 1$ hexo d 即可访问：1http://[yourGithubAccount].github.io/ 发表新文章1$ hexo new &quot;title&quot; 然后在 source/_post 下会生成该.md文件，即可使用编辑器编写了编写过程中，可以在本地实时查看效果，很是方便。支持 markdown，不了解的自行 百度 。 编写完成后，部署还是一样的 1$ hexo d -g 如果部署过程中报错，可执行以下命令重新部署 123$ hexo clean$ hexo generate$ hexo deploy 添加自定义页面1$ hexo new page &quot;about&quot; 该命令会生成 source/about/index.md，编辑即可 插件的升级与卸载12$ npm update$ npm uninstall &lt;plugin-name&gt; 更新 hexo1npm update -g hexo 绑定自定义域名在 /source/ 目录下新建内容为自定义域名的 CNAME 文件，部署即可（域名设置略） 备注：Hexo简写命令 1234hexo n #newhexo g #generatehexo s #serverhexo d #deploy","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://suiang.cn/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://suiang.cn/tags/Github/"}]},{"title":"不声明直接调用 API 函数","date":"2020-09-10T16:59:13.907Z","path":"posts/35919/","text":"一般建议不要先声明API再去调用，直接调用更方便也更节省资源(除非有特殊的数据类型必须通过声明API来指定)。 示例： ::User32.MessageBox(0,&quot;测试&quot;,&quot;标题&quot;,0) 添加参数的规则 调用约定在加载DLL的参数中指定,支持cdecl不定个数参数,有很多API根据不同的用法可以传入不同类型的参数， 如果我们在aardio中不是先写一个API声明，而是直接去调用API，这时候就可以根据需要更灵活的改变参数类型。一般建议不要先声明API再去调用 - 直接调用更方便也更节省资源(除非有特殊的数据类型必须通过声明API来指定)。 null参数不可省略 数值参数一律处理为32位int整型，32位整数类型，小于32位的整数、枚举类型、8位或32位bool值都跟int 32位数值兼容，可以直接写在参数里,示例： 32位整型以及小于32位的整型参数都可以直接传入aardio数值。例如C语言API声明为：void setNumber( short n )在aardio里如下调用就可以 dll.setNumber( 123 ) 64位整数（C语言中的long long)可以math.size64对象表示，或者用两个数值参数表示一个64位整数值参数，其中第一个参数表示低32位数值,第二个参数表示高32位数值（一般可以直接写0）。 对于任何数值类型的指针（输出参数）一律使用结构体表示，例如C语言API声明为：void getNumber( short *n ) 在aardio里如下调用就可以 12var n = &#123; word value &#125;dll.getNumber(n) API函数中的数组指针，在aardio中可以使用结构体指针替代，例如C语言中的 int data[4]; 在aardio中写为 {int data[4];} 如果是字节数组指针也可以使用raw.buffer()函数创建的字节数组替代。 所有结构体一律处理为输出参数并在aardio返回值中返回，其他类型只能作为输入参数。注意在aardio中，任何结构体在API调用中传递的都是结构体指针（传址）。 因为没有参数类型声明，调用代码有责任事先检查并保证参数类型正确，传入错误的参数可能导致程序异常。 获取返回值的规则 直接调用API的 返回值默认为int类型 可以使用[API尾标]改变返回值为其他类型 未声明的 API函数自身在aardio中是一个普通的aardio函数对象，不能作为函数指针参数传给 API参数（声明后的API函数对象是可以的） 使用 [ API 尾标 ]当不声明直接调用API时，API函数名尾部如果不是大写字符，则可以使用一个大写的特定字符（API尾标）修改默认的API调用规则，在API函数名后添加尾标，不会影响到查找API函数的结果，无论真实的API带不带指定的尾标 - aardio都能找到真实的函数。 所有可用的[API尾标]如下（函数名的最后一个特定字符是尾标）： dll.ApiNameW() 切换到Unicode版本，字符串UTF8UTF16双向转换dll.ApiNameA() 切换到ANSI版本,字符串不作任何转换dll.ApiNameL() 返回值为64位LONG类型dll.ApiNameP() 返回值为指针类型dll.ApiNameD() 返回值为double浮点数dll.ApiNameF() 返回值为float浮点数dll.ApiNameB() 返回值为 C++ 中的8位bool类型 如何使用字符串 字符串一般直接转换为字符串指针，buffer类型字节数组也可以作为字符串指针使用，如果API需要向字符串指向的内存中写入数据，那么必须使用raw.buffer()函数创建定长的字节数组。普通的aardio字符串指向的内存是禁止写入的（aardio中修改普通字符串会返回新的字符串对象，而不是在原内存上修改数据） 对于非Unicode API字符串直接输入原始的数据（对于文本就是UTF8编码），对于声明为Unicode版本的API，字符串会被强制转换为Unicode(UTF16)，但buffer类型的参数仍然会以二进制方式使用原始数据与API交互（不会做文本编码转换） 可以在 raw.loadDll() 加载 DLL时在调用约定中添加,unicode声明一个 DLL默认使用Unicode API。 也可以在函数名后添加尾标 W 声明一个Unicode API, 即使真实的API函数名后面并没有 W 尾标，你仍然可以添加 W 尾标调用 API。aardio在找不到该 API函数时，会移除 W 尾标，并且认为该 API函数是一个Unicode API，注意 W 必须大写并紧跟在小写字母后面。 直接调用 API时，如果目标 API函数并不存在，而是存在加 W 尾标的Unicode API,aardio将会自动切换到Unicode API，并在调用函数时，自动将aardio的UTF8编码转换为 API所需要的UTF16编码。 反之，在API函数名后也可以显式的添加 A 尾标强制声明此 API是一个 ANSI 版本的函数（对字符串参数不使用任何 Unicode 转换，即使加载 DLL时在调用约定中声明了默认以 unicode 方式调用），规则同上 - 也即真实的API函数名后面有没有 A 尾标并不重要，在aardio中都可以加上 A 尾标。 一些API在接收字符串、字节数组等参数时，通常下一个参数需要指定内存长度， aardio中用#操作符取字符串、缓冲区的长度时，返回的都是字节长度，一些 API可能需要你传入字符个数， 发果是Unicode版本的 API一个字符为两个字节，对于一个UTF8字符串应当事用string.len()函数得到真正的字符长度, 而Unicode字符串则用#取到字节长度后乘以2即可。","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"},{"name":"API","slug":"API","permalink":"http://suiang.cn/tags/API/"}]},{"title":"Hello World！","date":"2020-09-10T16:59:13.904Z","path":"posts/16107/","text":"欢迎使用 Hexo ! 这是你的第一篇文章。检查 文档 以获取更多信息。如果你在使用Hexo时遇到任何问题，你可以在 故障排除 中找到答案，或者你可以在 GitHub 提问。 快速开始创建新帖子1$ hexo new \"My New Post\" 更多信息: Writing 运行服务器1$ hexo server 更多信息: Server 生成静态文件1$ hexo generate 更多信息: Generating 部署到远程站点1$ hexo deploy 更多信息: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://suiang.cn/tags/Hexo/"}]},{"title":"WebDriver 协议客户端","date":"2020-09-10T16:59:13.903Z","path":"posts/39047/","text":"WebDriver 是用于控制浏览器的一个协议，我们试试用 aardio 来实现这个功能，我们只需要浏览器提供的接口。 例如 chromeDriver.exe （ 不同版本的chrome要下载不同版本的 chromeDriver.exe ）。其他的东西我们就不需要了，安装这个安装那个多麻烦对吗？！ 看一下其他语言的封装库，代码可能很多，但是不要被吓倒了，用 aardio 我们真的只要几句代码就可以实现 WebDriver 客户端了。 12345678910111213141516171819202122232425262728293031import web.rest.jsonClient;//协议文档 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocolvar http = web.rest.jsonClient();var webDriver = http.api(\"http://localhost:9515/\");//改成chromedriver的实际端口//创建会话，打开chrome浏览器var chrome = webDriver.session( desiredCapabilities = &#123; browserName = \"chrome\" &#125;);//获取打开的浏览器会话var session = webDriver.session[chrome.sessionId];//打开网页session.url( url = \"http://www.baidu.com\")//查找百度输入框var ele = session.element( using = \"id\"; value = \"kw\";)//在网页输入框输入内容session.element[ ele.value.ELEMENT ].value( value = &#123; \"ChromeDriver\" &#125;;)","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"},{"name":"Chrome","slug":"Chrome","permalink":"http://suiang.cn/tags/Chrome/"},{"name":"WebDriver","slug":"WebDriver","permalink":"http://suiang.cn/tags/WebDriver/"}]},{"title":"Chrome 系列范例","date":"2020-09-10T16:59:13.901Z","path":"posts/57740/","text":"大家知道Chrome每个版本的适用ChromeDriver版本都不一样，安装不同的Chrome就要去下载不同的ChromeDriver.exe，而且还要命令行启动，绑定固定端口一搞不好还会跟别的进程冲突了。 现在用aardio 最新版中提供的 chrome.driver 所有麻烦都可以解决了，chrome.driver 会自动查找Chrome的安装位置、版本号，自动匹配最合适的ChromeDriver版本，并且负责自动下载安装，自动分配空闲端口，所有事情全自动准备好，只要运行下面的代码就可以了。 现在看代码，用法非常简单: 12345678910111213141516171819202122//WebDriver自动化import chrome.driver;//创建chromeDriver对象//协议文档 https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocolvar driver = chrome.driver();//创建会话，打开chrome浏览器，Chrome新版会强制显示控制台var browser = driver.startBrowser();//打开网页browser.go(\"http://www.so.com\")//查找文本输入框var ele = browser.querySelector(\"#input\");//在网页输入框输入内容ele.setValue( \"ChromeDriver\" )//模拟点击按钮browser.querySelector(\"#search-button\").click(); 下面的问题在新版中已解决，可忽略： 注意 Chrome新版会强制显示控制台（ 隐藏也会强行弹出黑窗口，旧版可以隐藏这个黑窗口 ）， 如果想隐藏黑窗口，那么可以用旧版Chrome，在创建 chrome.driver对象时可以在参数中自定义chrome.exe的路径。 调用 Electron也可以通过 ChromeDriver 调用 Electron，几句代码就可以了： 12345678910111213141516171819202122import electron.driver;//创建chromeDriver对象,协议文档var driver = electron.driver();//替换electron默认的开始页driver.addArguments(\"--app=http://www.so.com\");//创建会话，打开chrome浏览器，Chrome新版会强制显示控制台var browser = driver.startBrowser();//打开网页//browser.go(\"http://www.so.com\")//查找文本输入框var ele = browser.querySelector(\"#input\");//在网页输入框输入内容ele.setValue( \"ChromeDriver\" )//模拟点击按钮browser.querySelector(\"#search-button\").click(); 修改 User Agent12345678import chrome.driver;var driver = chrome.driver();driver.addArguments(\"--user-agent=mychrome\")//打开网页driver.startBrowser().go(\"http://www.ip138.com/useragent/\") chrome启动参数大全： 设置代理12345678import chrome.driver;var driver = chrome.driver();driver.setProxy( proxyType = \"manual\"; httpProxy = \"127.0.0.1:12043\") 也可以下面这样写: 12345678910import chrome.driver;var driver = chrome.driver();var browser = driver.startBrowser( proxy =&#123; proxyType = \"manual\"; httpProxy = \"127.0.0.1:12043\" &#125;); 新版功能chrome.driver新版功能演示，操作chrome就像直接执行Javascript函数那么简单 123456789101112131415import chrome.driver;var driver = chrome.driver();//启动浏览器browser = driver.startBrowser();//打开网页browser.go(\"http://www.so.com\")//查询元素,并且使用元素的querySelector函数查询子元素browser.querySelector(\"body\").querySelector(\"#input\").setValue( \"ChromeDriver\" )//模拟点击按钮browser.querySelector(\"#search-button\").click() 隐藏控制台网上一些讨论认为这个问题无解，WebDriver也没有找到相关参数，直觉这个可能在启动参数里打开控制台，于是我写了一个假的 chrome.exe，再用 ChromeDriver.exe 调用他，代码如下： 1234567import console;import win.clipwin.clip.write(_CMDLINE)console.log(_CMDLINE);console.pause(); chrome.exe获得的启动参数如下： 1--disable-background-networking --disable-client-side-phishing-detection --disable-default-apps --disable-hang-monitor --disable-popup-blocking --disable-prompt-on-repost --disable-sync --disable-web-resources --enable-automation --enable-logging --force-fieldtrials=SiteIsolationExtensions/Control --ignore-certificate-errors --load-extension=&quot;C:\\Users\\***\\AppData\\Local\\Temp\\***\\internal&quot; --log-level=0 --metrics-recording-only --no-first-run --password-store=basic --remote-debugging-port=0 --test-type=webdriver --use-mock-keychain --user-data-dir=&quot;C:\\Users\\***\\AppData\\Local\\Temp\\***&quot; data:, 我们看到可疑参数--enable-logging，进一步测试发现：排除这个参数就可以关闭新版chrome启动跳出来的控制台窗口了，示例代码： 123456789import chrome.driver;var driver = chrome.driver( );driver.setOptions( excludeSwitches =&#123;\"enable-logging\"&#125; //注意这里参数前千万不要加 --)driver.addArguments(\"--app=http://www.aardio.com\")var browser = driver.startBrowser(); 已更新 chrome.driver 默认禁用控制台窗口， 但仍然可以使用 driver.addArguments(&quot;--enable-logging&quot;) 启用这个参数。 app、driver 交互aardio新版经过大力改进，现在 chrome.app, chrome.driver 已经可以相互结合使用，chrome与aardio交互更加简单方便。下面是一个简单的例子： 12345678910111213141516171819202122232425262728293031import chrome.app;var app = chrome.app();import chrome.driver;var driver = chrome.driver();//指定允许chrome中使用JS直接调用的函数app.external = &#123; test = function()&#123; app.msgbox(\"页面js调用了aardio函数\"); &#125;&#125;//正式的启动chrome进程app.start(\"http://www.aardio.com\",function(args)&#123; //启动浏览器，加载aardio.js，并打开ChromeDriver自动化接口 var browser = driver.startAppBrowser(app,args); //执行JS脚本 browser.doScript(` document.addEventListener(\"click\", function(event) &#123; aardio.test(); &#125;); `) return browser;&#125;);win.loopMessage(); 禁用自动化测试提示方法一： 123import chrome.driver;var driver = chrome.driver();driver.removeArguments(\"--enable-automation\") 虽然不显示上面的提示了，但是弹出一个更大的警告。 方法二： 123import chrome.driver;var driver = chrome.driver();driver.addArguments(\"--disable-infobars\"); 不显示上面的提示，也没有警告了，但是可以看到提示框显示然后快速的关掉，会闪烁一下。 方法三: 123import chrome.driver;var driver = chrome.driver();driver.addArguments(\"--app=http://www.so.com/index.html\"); 用–app模式的方法完美，地址栏、提示框、警告都去掉了， 但是有一个奇怪的事情是，启动网址要写成 http://www.so.com/index.html 这样，如果不写 index.html 有时候会白屏，但不是每个网站都这样。 清理临时文件Chrome每个进程只能绑定单独的用户目录 - 才能创建单独的远程调试端口，ChromeDriver 的办法是每次都创建一个临时的用户目录，然后每次都创建新的临时用户目录，而且又不负责删除（其实可以设置为重启系统自动删除，不知道Chrome为什么没有这么做），所以我们只好自己清理了，代码如下： 12345678910111213141516import console;import fsys;fsys.enum( fsys.getTempDir(), \"scoped_dir*_*\", function(dir,filename,fullpath,findData)&#123; if(!filename)&#123; if( ..io.exist( io.joinpath(fullpath,\"DevToolsActivePort\") ) )&#123; fsys.delete(fullpath) &#125; if( ..io.exist( io.joinpath(fullpath,\"internal.zip\") ) )&#123; fsys.delete(fullpath) &#125; &#125; &#125;,false);console.pause(true);","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"},{"name":"Chrome","slug":"Chrome","permalink":"http://suiang.cn/tags/Chrome/"},{"name":"WebDriver","slug":"WebDriver","permalink":"http://suiang.cn/tags/WebDriver/"}]},{"title":"AArdio 简单服务器示例","date":"2020-09-10T16:59:13.900Z","path":"posts/214/","text":"使用 aardio 中的 simpleHttpServer 库实现 python 例程中的 HTTP 服务器功能！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344//简单服务器示例import console;import process;import wsock.tcp.simpleHttpServer;var srvHttp = wsock.tcp.simpleHttpServer()srvHttp.documentRoot = \"d:\\\"console.log(srvHttp.getUrl());process.execute(srvHttp.getUrl());srvHttp.run( function(response,request)&#123; import fsys; import inet.url; if(!fsys.isDir(request.path) ) &#123; if( ..io.exist(request.path) ) response.loadcode(request.path) else &#123; request.path = fsys.getParentDir(request.path) &#125; &#125; response.write(\" &lt;title&gt;Directory listing for /&lt;/title&gt;&lt;body&gt;&lt;h2&gt;Directory listing for\",request.path,\"&lt;/h2&gt;&lt;hr&gt;&lt;ul&gt;\") var file,dir = fsys.list(request.path,,\"*.*\"); for(i=1;#dir;1)&#123; response.write('&lt;li&gt;&lt;a href=\"' ,inet.url.append(request.path,dir[ i ]) ,'\"&gt;'+tostring(i)+\") \",dir[ i ],'&lt;/a&gt;&lt;br&gt;\\r\\n'); &#125; for(i=1;#file;1)&#123; response.write('&lt;li&gt;&lt;a href=\"' ,inet.url.append(request.path,file[ i ]) ,'\"&gt;'+tostring(i)+\") \",file[ i ],'&lt;/a&gt;&lt;br&gt;\\r\\n'); &#125; &#125;) 用aardio实现python例程中的HTTP服务器功能","tags":[{"name":"AArdio","slug":"AArdio","permalink":"http://suiang.cn/tags/AArdio/"}]}]